// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               unknown
// source: skillchain/filestorage/tx.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Params } from "./params";

export const protobufPackage = "skillchain.filestorage";

/** MsgUpdateParams is the Msg/UpdateParams request type. */
export interface MsgUpdateParams {
  /** authority is the address that controls the module (defaults to x/gov unless overwritten). */
  authority: string;
  /** NOTE: All parameters must be supplied. */
  params: Params | undefined;
}

/**
 * MsgUpdateParamsResponse defines the response structure for executing a
 * MsgUpdateParams message.
 */
export interface MsgUpdateParamsResponse {
}

export interface MsgCreateFileRecord {
  creator: string;
  index: string;
  owner: string;
  filename: string;
  fileHash: string;
  fileSize: number;
  contentType: string;
  uploadDate: number;
  ipfsHash: string;
  metadata: string;
  isPublic: boolean;
}

export interface MsgCreateFileRecordResponse {
}

export interface MsgUpdateFileRecord {
  creator: string;
  index: string;
  owner: string;
  filename: string;
  fileHash: string;
  fileSize: number;
  contentType: string;
  uploadDate: number;
  ipfsHash: string;
  metadata: string;
  isPublic: boolean;
}

export interface MsgUpdateFileRecordResponse {
}

export interface MsgDeleteFileRecord {
  creator: string;
  index: string;
}

export interface MsgDeleteFileRecordResponse {
}

export interface MsgCreateFilePermission {
  creator: string;
  index: string;
  fileId: string;
  userAddress: string;
  permissionLevel: string;
  grantedBy: string;
  grantedAt: number;
  expiresAt: number;
}

export interface MsgCreateFilePermissionResponse {
}

export interface MsgUpdateFilePermission {
  creator: string;
  index: string;
  fileId: string;
  userAddress: string;
  permissionLevel: string;
  grantedBy: string;
  grantedAt: number;
  expiresAt: number;
}

export interface MsgUpdateFilePermissionResponse {
}

export interface MsgDeleteFilePermission {
  creator: string;
  index: string;
}

export interface MsgDeleteFilePermissionResponse {
}

function createBaseMsgUpdateParams(): MsgUpdateParams {
  return { authority: "", params: undefined };
}

export const MsgUpdateParams: MessageFns<MsgUpdateParams> = {
  encode(message: MsgUpdateParams, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.authority !== "") {
      writer.uint32(10).string(message.authority);
    }
    if (message.params !== undefined) {
      Params.encode(message.params, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateParams {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.authority = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.params = Params.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUpdateParams {
    return {
      authority: isSet(object.authority) ? globalThis.String(object.authority) : "",
      params: isSet(object.params) ? Params.fromJSON(object.params) : undefined,
    };
  },

  toJSON(message: MsgUpdateParams): unknown {
    const obj: any = {};
    if (message.authority !== "") {
      obj.authority = message.authority;
    }
    if (message.params !== undefined) {
      obj.params = Params.toJSON(message.params);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgUpdateParams>, I>>(base?: I): MsgUpdateParams {
    return MsgUpdateParams.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgUpdateParams>, I>>(object: I): MsgUpdateParams {
    const message = createBaseMsgUpdateParams();
    message.authority = object.authority ?? "";
    message.params = (object.params !== undefined && object.params !== null)
      ? Params.fromPartial(object.params)
      : undefined;
    return message;
  },
};

function createBaseMsgUpdateParamsResponse(): MsgUpdateParamsResponse {
  return {};
}

export const MsgUpdateParamsResponse: MessageFns<MsgUpdateParamsResponse> = {
  encode(_: MsgUpdateParamsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateParamsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateParamsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgUpdateParamsResponse {
    return {};
  },

  toJSON(_: MsgUpdateParamsResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgUpdateParamsResponse>, I>>(base?: I): MsgUpdateParamsResponse {
    return MsgUpdateParamsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgUpdateParamsResponse>, I>>(_: I): MsgUpdateParamsResponse {
    const message = createBaseMsgUpdateParamsResponse();
    return message;
  },
};

function createBaseMsgCreateFileRecord(): MsgCreateFileRecord {
  return {
    creator: "",
    index: "",
    owner: "",
    filename: "",
    fileHash: "",
    fileSize: 0,
    contentType: "",
    uploadDate: 0,
    ipfsHash: "",
    metadata: "",
    isPublic: false,
  };
}

export const MsgCreateFileRecord: MessageFns<MsgCreateFileRecord> = {
  encode(message: MsgCreateFileRecord, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.index !== "") {
      writer.uint32(18).string(message.index);
    }
    if (message.owner !== "") {
      writer.uint32(26).string(message.owner);
    }
    if (message.filename !== "") {
      writer.uint32(34).string(message.filename);
    }
    if (message.fileHash !== "") {
      writer.uint32(42).string(message.fileHash);
    }
    if (message.fileSize !== 0) {
      writer.uint32(48).uint64(message.fileSize);
    }
    if (message.contentType !== "") {
      writer.uint32(58).string(message.contentType);
    }
    if (message.uploadDate !== 0) {
      writer.uint32(64).uint64(message.uploadDate);
    }
    if (message.ipfsHash !== "") {
      writer.uint32(74).string(message.ipfsHash);
    }
    if (message.metadata !== "") {
      writer.uint32(82).string(message.metadata);
    }
    if (message.isPublic !== false) {
      writer.uint32(88).bool(message.isPublic);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgCreateFileRecord {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCreateFileRecord();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.index = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.owner = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.filename = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.fileHash = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.fileSize = longToNumber(reader.uint64());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.contentType = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.uploadDate = longToNumber(reader.uint64());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.ipfsHash = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.metadata = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.isPublic = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgCreateFileRecord {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      index: isSet(object.index) ? globalThis.String(object.index) : "",
      owner: isSet(object.owner) ? globalThis.String(object.owner) : "",
      filename: isSet(object.filename) ? globalThis.String(object.filename) : "",
      fileHash: isSet(object.fileHash) ? globalThis.String(object.fileHash) : "",
      fileSize: isSet(object.fileSize) ? globalThis.Number(object.fileSize) : 0,
      contentType: isSet(object.contentType) ? globalThis.String(object.contentType) : "",
      uploadDate: isSet(object.uploadDate) ? globalThis.Number(object.uploadDate) : 0,
      ipfsHash: isSet(object.ipfsHash) ? globalThis.String(object.ipfsHash) : "",
      metadata: isSet(object.metadata) ? globalThis.String(object.metadata) : "",
      isPublic: isSet(object.isPublic) ? globalThis.Boolean(object.isPublic) : false,
    };
  },

  toJSON(message: MsgCreateFileRecord): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.index !== "") {
      obj.index = message.index;
    }
    if (message.owner !== "") {
      obj.owner = message.owner;
    }
    if (message.filename !== "") {
      obj.filename = message.filename;
    }
    if (message.fileHash !== "") {
      obj.fileHash = message.fileHash;
    }
    if (message.fileSize !== 0) {
      obj.fileSize = Math.round(message.fileSize);
    }
    if (message.contentType !== "") {
      obj.contentType = message.contentType;
    }
    if (message.uploadDate !== 0) {
      obj.uploadDate = Math.round(message.uploadDate);
    }
    if (message.ipfsHash !== "") {
      obj.ipfsHash = message.ipfsHash;
    }
    if (message.metadata !== "") {
      obj.metadata = message.metadata;
    }
    if (message.isPublic !== false) {
      obj.isPublic = message.isPublic;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgCreateFileRecord>, I>>(base?: I): MsgCreateFileRecord {
    return MsgCreateFileRecord.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgCreateFileRecord>, I>>(object: I): MsgCreateFileRecord {
    const message = createBaseMsgCreateFileRecord();
    message.creator = object.creator ?? "";
    message.index = object.index ?? "";
    message.owner = object.owner ?? "";
    message.filename = object.filename ?? "";
    message.fileHash = object.fileHash ?? "";
    message.fileSize = object.fileSize ?? 0;
    message.contentType = object.contentType ?? "";
    message.uploadDate = object.uploadDate ?? 0;
    message.ipfsHash = object.ipfsHash ?? "";
    message.metadata = object.metadata ?? "";
    message.isPublic = object.isPublic ?? false;
    return message;
  },
};

function createBaseMsgCreateFileRecordResponse(): MsgCreateFileRecordResponse {
  return {};
}

export const MsgCreateFileRecordResponse: MessageFns<MsgCreateFileRecordResponse> = {
  encode(_: MsgCreateFileRecordResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgCreateFileRecordResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCreateFileRecordResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgCreateFileRecordResponse {
    return {};
  },

  toJSON(_: MsgCreateFileRecordResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgCreateFileRecordResponse>, I>>(base?: I): MsgCreateFileRecordResponse {
    return MsgCreateFileRecordResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgCreateFileRecordResponse>, I>>(_: I): MsgCreateFileRecordResponse {
    const message = createBaseMsgCreateFileRecordResponse();
    return message;
  },
};

function createBaseMsgUpdateFileRecord(): MsgUpdateFileRecord {
  return {
    creator: "",
    index: "",
    owner: "",
    filename: "",
    fileHash: "",
    fileSize: 0,
    contentType: "",
    uploadDate: 0,
    ipfsHash: "",
    metadata: "",
    isPublic: false,
  };
}

export const MsgUpdateFileRecord: MessageFns<MsgUpdateFileRecord> = {
  encode(message: MsgUpdateFileRecord, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.index !== "") {
      writer.uint32(18).string(message.index);
    }
    if (message.owner !== "") {
      writer.uint32(26).string(message.owner);
    }
    if (message.filename !== "") {
      writer.uint32(34).string(message.filename);
    }
    if (message.fileHash !== "") {
      writer.uint32(42).string(message.fileHash);
    }
    if (message.fileSize !== 0) {
      writer.uint32(48).uint64(message.fileSize);
    }
    if (message.contentType !== "") {
      writer.uint32(58).string(message.contentType);
    }
    if (message.uploadDate !== 0) {
      writer.uint32(64).uint64(message.uploadDate);
    }
    if (message.ipfsHash !== "") {
      writer.uint32(74).string(message.ipfsHash);
    }
    if (message.metadata !== "") {
      writer.uint32(82).string(message.metadata);
    }
    if (message.isPublic !== false) {
      writer.uint32(88).bool(message.isPublic);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateFileRecord {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateFileRecord();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.index = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.owner = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.filename = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.fileHash = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.fileSize = longToNumber(reader.uint64());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.contentType = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.uploadDate = longToNumber(reader.uint64());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.ipfsHash = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.metadata = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.isPublic = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUpdateFileRecord {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      index: isSet(object.index) ? globalThis.String(object.index) : "",
      owner: isSet(object.owner) ? globalThis.String(object.owner) : "",
      filename: isSet(object.filename) ? globalThis.String(object.filename) : "",
      fileHash: isSet(object.fileHash) ? globalThis.String(object.fileHash) : "",
      fileSize: isSet(object.fileSize) ? globalThis.Number(object.fileSize) : 0,
      contentType: isSet(object.contentType) ? globalThis.String(object.contentType) : "",
      uploadDate: isSet(object.uploadDate) ? globalThis.Number(object.uploadDate) : 0,
      ipfsHash: isSet(object.ipfsHash) ? globalThis.String(object.ipfsHash) : "",
      metadata: isSet(object.metadata) ? globalThis.String(object.metadata) : "",
      isPublic: isSet(object.isPublic) ? globalThis.Boolean(object.isPublic) : false,
    };
  },

  toJSON(message: MsgUpdateFileRecord): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.index !== "") {
      obj.index = message.index;
    }
    if (message.owner !== "") {
      obj.owner = message.owner;
    }
    if (message.filename !== "") {
      obj.filename = message.filename;
    }
    if (message.fileHash !== "") {
      obj.fileHash = message.fileHash;
    }
    if (message.fileSize !== 0) {
      obj.fileSize = Math.round(message.fileSize);
    }
    if (message.contentType !== "") {
      obj.contentType = message.contentType;
    }
    if (message.uploadDate !== 0) {
      obj.uploadDate = Math.round(message.uploadDate);
    }
    if (message.ipfsHash !== "") {
      obj.ipfsHash = message.ipfsHash;
    }
    if (message.metadata !== "") {
      obj.metadata = message.metadata;
    }
    if (message.isPublic !== false) {
      obj.isPublic = message.isPublic;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgUpdateFileRecord>, I>>(base?: I): MsgUpdateFileRecord {
    return MsgUpdateFileRecord.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgUpdateFileRecord>, I>>(object: I): MsgUpdateFileRecord {
    const message = createBaseMsgUpdateFileRecord();
    message.creator = object.creator ?? "";
    message.index = object.index ?? "";
    message.owner = object.owner ?? "";
    message.filename = object.filename ?? "";
    message.fileHash = object.fileHash ?? "";
    message.fileSize = object.fileSize ?? 0;
    message.contentType = object.contentType ?? "";
    message.uploadDate = object.uploadDate ?? 0;
    message.ipfsHash = object.ipfsHash ?? "";
    message.metadata = object.metadata ?? "";
    message.isPublic = object.isPublic ?? false;
    return message;
  },
};

function createBaseMsgUpdateFileRecordResponse(): MsgUpdateFileRecordResponse {
  return {};
}

export const MsgUpdateFileRecordResponse: MessageFns<MsgUpdateFileRecordResponse> = {
  encode(_: MsgUpdateFileRecordResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateFileRecordResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateFileRecordResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgUpdateFileRecordResponse {
    return {};
  },

  toJSON(_: MsgUpdateFileRecordResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgUpdateFileRecordResponse>, I>>(base?: I): MsgUpdateFileRecordResponse {
    return MsgUpdateFileRecordResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgUpdateFileRecordResponse>, I>>(_: I): MsgUpdateFileRecordResponse {
    const message = createBaseMsgUpdateFileRecordResponse();
    return message;
  },
};

function createBaseMsgDeleteFileRecord(): MsgDeleteFileRecord {
  return { creator: "", index: "" };
}

export const MsgDeleteFileRecord: MessageFns<MsgDeleteFileRecord> = {
  encode(message: MsgDeleteFileRecord, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.index !== "") {
      writer.uint32(18).string(message.index);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgDeleteFileRecord {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgDeleteFileRecord();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.index = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgDeleteFileRecord {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      index: isSet(object.index) ? globalThis.String(object.index) : "",
    };
  },

  toJSON(message: MsgDeleteFileRecord): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.index !== "") {
      obj.index = message.index;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgDeleteFileRecord>, I>>(base?: I): MsgDeleteFileRecord {
    return MsgDeleteFileRecord.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgDeleteFileRecord>, I>>(object: I): MsgDeleteFileRecord {
    const message = createBaseMsgDeleteFileRecord();
    message.creator = object.creator ?? "";
    message.index = object.index ?? "";
    return message;
  },
};

function createBaseMsgDeleteFileRecordResponse(): MsgDeleteFileRecordResponse {
  return {};
}

export const MsgDeleteFileRecordResponse: MessageFns<MsgDeleteFileRecordResponse> = {
  encode(_: MsgDeleteFileRecordResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgDeleteFileRecordResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgDeleteFileRecordResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgDeleteFileRecordResponse {
    return {};
  },

  toJSON(_: MsgDeleteFileRecordResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgDeleteFileRecordResponse>, I>>(base?: I): MsgDeleteFileRecordResponse {
    return MsgDeleteFileRecordResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgDeleteFileRecordResponse>, I>>(_: I): MsgDeleteFileRecordResponse {
    const message = createBaseMsgDeleteFileRecordResponse();
    return message;
  },
};

function createBaseMsgCreateFilePermission(): MsgCreateFilePermission {
  return {
    creator: "",
    index: "",
    fileId: "",
    userAddress: "",
    permissionLevel: "",
    grantedBy: "",
    grantedAt: 0,
    expiresAt: 0,
  };
}

export const MsgCreateFilePermission: MessageFns<MsgCreateFilePermission> = {
  encode(message: MsgCreateFilePermission, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.index !== "") {
      writer.uint32(18).string(message.index);
    }
    if (message.fileId !== "") {
      writer.uint32(26).string(message.fileId);
    }
    if (message.userAddress !== "") {
      writer.uint32(34).string(message.userAddress);
    }
    if (message.permissionLevel !== "") {
      writer.uint32(42).string(message.permissionLevel);
    }
    if (message.grantedBy !== "") {
      writer.uint32(50).string(message.grantedBy);
    }
    if (message.grantedAt !== 0) {
      writer.uint32(56).uint64(message.grantedAt);
    }
    if (message.expiresAt !== 0) {
      writer.uint32(64).uint64(message.expiresAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgCreateFilePermission {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCreateFilePermission();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.index = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.fileId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.userAddress = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.permissionLevel = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.grantedBy = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.grantedAt = longToNumber(reader.uint64());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.expiresAt = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgCreateFilePermission {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      index: isSet(object.index) ? globalThis.String(object.index) : "",
      fileId: isSet(object.fileId) ? globalThis.String(object.fileId) : "",
      userAddress: isSet(object.userAddress) ? globalThis.String(object.userAddress) : "",
      permissionLevel: isSet(object.permissionLevel) ? globalThis.String(object.permissionLevel) : "",
      grantedBy: isSet(object.grantedBy) ? globalThis.String(object.grantedBy) : "",
      grantedAt: isSet(object.grantedAt) ? globalThis.Number(object.grantedAt) : 0,
      expiresAt: isSet(object.expiresAt) ? globalThis.Number(object.expiresAt) : 0,
    };
  },

  toJSON(message: MsgCreateFilePermission): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.index !== "") {
      obj.index = message.index;
    }
    if (message.fileId !== "") {
      obj.fileId = message.fileId;
    }
    if (message.userAddress !== "") {
      obj.userAddress = message.userAddress;
    }
    if (message.permissionLevel !== "") {
      obj.permissionLevel = message.permissionLevel;
    }
    if (message.grantedBy !== "") {
      obj.grantedBy = message.grantedBy;
    }
    if (message.grantedAt !== 0) {
      obj.grantedAt = Math.round(message.grantedAt);
    }
    if (message.expiresAt !== 0) {
      obj.expiresAt = Math.round(message.expiresAt);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgCreateFilePermission>, I>>(base?: I): MsgCreateFilePermission {
    return MsgCreateFilePermission.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgCreateFilePermission>, I>>(object: I): MsgCreateFilePermission {
    const message = createBaseMsgCreateFilePermission();
    message.creator = object.creator ?? "";
    message.index = object.index ?? "";
    message.fileId = object.fileId ?? "";
    message.userAddress = object.userAddress ?? "";
    message.permissionLevel = object.permissionLevel ?? "";
    message.grantedBy = object.grantedBy ?? "";
    message.grantedAt = object.grantedAt ?? 0;
    message.expiresAt = object.expiresAt ?? 0;
    return message;
  },
};

function createBaseMsgCreateFilePermissionResponse(): MsgCreateFilePermissionResponse {
  return {};
}

export const MsgCreateFilePermissionResponse: MessageFns<MsgCreateFilePermissionResponse> = {
  encode(_: MsgCreateFilePermissionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgCreateFilePermissionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCreateFilePermissionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgCreateFilePermissionResponse {
    return {};
  },

  toJSON(_: MsgCreateFilePermissionResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgCreateFilePermissionResponse>, I>>(base?: I): MsgCreateFilePermissionResponse {
    return MsgCreateFilePermissionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgCreateFilePermissionResponse>, I>>(_: I): MsgCreateFilePermissionResponse {
    const message = createBaseMsgCreateFilePermissionResponse();
    return message;
  },
};

function createBaseMsgUpdateFilePermission(): MsgUpdateFilePermission {
  return {
    creator: "",
    index: "",
    fileId: "",
    userAddress: "",
    permissionLevel: "",
    grantedBy: "",
    grantedAt: 0,
    expiresAt: 0,
  };
}

export const MsgUpdateFilePermission: MessageFns<MsgUpdateFilePermission> = {
  encode(message: MsgUpdateFilePermission, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.index !== "") {
      writer.uint32(18).string(message.index);
    }
    if (message.fileId !== "") {
      writer.uint32(26).string(message.fileId);
    }
    if (message.userAddress !== "") {
      writer.uint32(34).string(message.userAddress);
    }
    if (message.permissionLevel !== "") {
      writer.uint32(42).string(message.permissionLevel);
    }
    if (message.grantedBy !== "") {
      writer.uint32(50).string(message.grantedBy);
    }
    if (message.grantedAt !== 0) {
      writer.uint32(56).uint64(message.grantedAt);
    }
    if (message.expiresAt !== 0) {
      writer.uint32(64).uint64(message.expiresAt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateFilePermission {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateFilePermission();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.index = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.fileId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.userAddress = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.permissionLevel = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.grantedBy = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.grantedAt = longToNumber(reader.uint64());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.expiresAt = longToNumber(reader.uint64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUpdateFilePermission {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      index: isSet(object.index) ? globalThis.String(object.index) : "",
      fileId: isSet(object.fileId) ? globalThis.String(object.fileId) : "",
      userAddress: isSet(object.userAddress) ? globalThis.String(object.userAddress) : "",
      permissionLevel: isSet(object.permissionLevel) ? globalThis.String(object.permissionLevel) : "",
      grantedBy: isSet(object.grantedBy) ? globalThis.String(object.grantedBy) : "",
      grantedAt: isSet(object.grantedAt) ? globalThis.Number(object.grantedAt) : 0,
      expiresAt: isSet(object.expiresAt) ? globalThis.Number(object.expiresAt) : 0,
    };
  },

  toJSON(message: MsgUpdateFilePermission): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.index !== "") {
      obj.index = message.index;
    }
    if (message.fileId !== "") {
      obj.fileId = message.fileId;
    }
    if (message.userAddress !== "") {
      obj.userAddress = message.userAddress;
    }
    if (message.permissionLevel !== "") {
      obj.permissionLevel = message.permissionLevel;
    }
    if (message.grantedBy !== "") {
      obj.grantedBy = message.grantedBy;
    }
    if (message.grantedAt !== 0) {
      obj.grantedAt = Math.round(message.grantedAt);
    }
    if (message.expiresAt !== 0) {
      obj.expiresAt = Math.round(message.expiresAt);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgUpdateFilePermission>, I>>(base?: I): MsgUpdateFilePermission {
    return MsgUpdateFilePermission.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgUpdateFilePermission>, I>>(object: I): MsgUpdateFilePermission {
    const message = createBaseMsgUpdateFilePermission();
    message.creator = object.creator ?? "";
    message.index = object.index ?? "";
    message.fileId = object.fileId ?? "";
    message.userAddress = object.userAddress ?? "";
    message.permissionLevel = object.permissionLevel ?? "";
    message.grantedBy = object.grantedBy ?? "";
    message.grantedAt = object.grantedAt ?? 0;
    message.expiresAt = object.expiresAt ?? 0;
    return message;
  },
};

function createBaseMsgUpdateFilePermissionResponse(): MsgUpdateFilePermissionResponse {
  return {};
}

export const MsgUpdateFilePermissionResponse: MessageFns<MsgUpdateFilePermissionResponse> = {
  encode(_: MsgUpdateFilePermissionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateFilePermissionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateFilePermissionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgUpdateFilePermissionResponse {
    return {};
  },

  toJSON(_: MsgUpdateFilePermissionResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgUpdateFilePermissionResponse>, I>>(base?: I): MsgUpdateFilePermissionResponse {
    return MsgUpdateFilePermissionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgUpdateFilePermissionResponse>, I>>(_: I): MsgUpdateFilePermissionResponse {
    const message = createBaseMsgUpdateFilePermissionResponse();
    return message;
  },
};

function createBaseMsgDeleteFilePermission(): MsgDeleteFilePermission {
  return { creator: "", index: "" };
}

export const MsgDeleteFilePermission: MessageFns<MsgDeleteFilePermission> = {
  encode(message: MsgDeleteFilePermission, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.creator !== "") {
      writer.uint32(10).string(message.creator);
    }
    if (message.index !== "") {
      writer.uint32(18).string(message.index);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgDeleteFilePermission {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgDeleteFilePermission();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.creator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.index = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgDeleteFilePermission {
    return {
      creator: isSet(object.creator) ? globalThis.String(object.creator) : "",
      index: isSet(object.index) ? globalThis.String(object.index) : "",
    };
  },

  toJSON(message: MsgDeleteFilePermission): unknown {
    const obj: any = {};
    if (message.creator !== "") {
      obj.creator = message.creator;
    }
    if (message.index !== "") {
      obj.index = message.index;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgDeleteFilePermission>, I>>(base?: I): MsgDeleteFilePermission {
    return MsgDeleteFilePermission.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgDeleteFilePermission>, I>>(object: I): MsgDeleteFilePermission {
    const message = createBaseMsgDeleteFilePermission();
    message.creator = object.creator ?? "";
    message.index = object.index ?? "";
    return message;
  },
};

function createBaseMsgDeleteFilePermissionResponse(): MsgDeleteFilePermissionResponse {
  return {};
}

export const MsgDeleteFilePermissionResponse: MessageFns<MsgDeleteFilePermissionResponse> = {
  encode(_: MsgDeleteFilePermissionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgDeleteFilePermissionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgDeleteFilePermissionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgDeleteFilePermissionResponse {
    return {};
  },

  toJSON(_: MsgDeleteFilePermissionResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MsgDeleteFilePermissionResponse>, I>>(base?: I): MsgDeleteFilePermissionResponse {
    return MsgDeleteFilePermissionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MsgDeleteFilePermissionResponse>, I>>(_: I): MsgDeleteFilePermissionResponse {
    const message = createBaseMsgDeleteFilePermissionResponse();
    return message;
  },
};

/** Msg defines the Msg service. */
export interface Msg {
  /**
   * UpdateParams defines a (governance) operation for updating the module
   * parameters. The authority defaults to the x/gov module account.
   */
  UpdateParams(request: MsgUpdateParams): Promise<MsgUpdateParamsResponse>;
  CreateFileRecord(request: MsgCreateFileRecord): Promise<MsgCreateFileRecordResponse>;
  UpdateFileRecord(request: MsgUpdateFileRecord): Promise<MsgUpdateFileRecordResponse>;
  DeleteFileRecord(request: MsgDeleteFileRecord): Promise<MsgDeleteFileRecordResponse>;
  CreateFilePermission(request: MsgCreateFilePermission): Promise<MsgCreateFilePermissionResponse>;
  UpdateFilePermission(request: MsgUpdateFilePermission): Promise<MsgUpdateFilePermissionResponse>;
  DeleteFilePermission(request: MsgDeleteFilePermission): Promise<MsgDeleteFilePermissionResponse>;
}

export const MsgServiceName = "skillchain.filestorage.Msg";
export class MsgClientImpl implements Msg {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || MsgServiceName;
    this.rpc = rpc;
    this.UpdateParams = this.UpdateParams.bind(this);
    this.CreateFileRecord = this.CreateFileRecord.bind(this);
    this.UpdateFileRecord = this.UpdateFileRecord.bind(this);
    this.DeleteFileRecord = this.DeleteFileRecord.bind(this);
    this.CreateFilePermission = this.CreateFilePermission.bind(this);
    this.UpdateFilePermission = this.UpdateFilePermission.bind(this);
    this.DeleteFilePermission = this.DeleteFilePermission.bind(this);
  }
  UpdateParams(request: MsgUpdateParams): Promise<MsgUpdateParamsResponse> {
    const data = MsgUpdateParams.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateParams", data);
    return promise.then((data) => MsgUpdateParamsResponse.decode(new BinaryReader(data)));
  }

  CreateFileRecord(request: MsgCreateFileRecord): Promise<MsgCreateFileRecordResponse> {
    const data = MsgCreateFileRecord.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateFileRecord", data);
    return promise.then((data) => MsgCreateFileRecordResponse.decode(new BinaryReader(data)));
  }

  UpdateFileRecord(request: MsgUpdateFileRecord): Promise<MsgUpdateFileRecordResponse> {
    const data = MsgUpdateFileRecord.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateFileRecord", data);
    return promise.then((data) => MsgUpdateFileRecordResponse.decode(new BinaryReader(data)));
  }

  DeleteFileRecord(request: MsgDeleteFileRecord): Promise<MsgDeleteFileRecordResponse> {
    const data = MsgDeleteFileRecord.encode(request).finish();
    const promise = this.rpc.request(this.service, "DeleteFileRecord", data);
    return promise.then((data) => MsgDeleteFileRecordResponse.decode(new BinaryReader(data)));
  }

  CreateFilePermission(request: MsgCreateFilePermission): Promise<MsgCreateFilePermissionResponse> {
    const data = MsgCreateFilePermission.encode(request).finish();
    const promise = this.rpc.request(this.service, "CreateFilePermission", data);
    return promise.then((data) => MsgCreateFilePermissionResponse.decode(new BinaryReader(data)));
  }

  UpdateFilePermission(request: MsgUpdateFilePermission): Promise<MsgUpdateFilePermissionResponse> {
    const data = MsgUpdateFilePermission.encode(request).finish();
    const promise = this.rpc.request(this.service, "UpdateFilePermission", data);
    return promise.then((data) => MsgUpdateFilePermissionResponse.decode(new BinaryReader(data)));
  }

  DeleteFilePermission(request: MsgDeleteFilePermission): Promise<MsgDeleteFilePermissionResponse> {
    const data = MsgDeleteFilePermission.encode(request).finish();
    const promise = this.rpc.request(this.service, "DeleteFilePermission", data);
    return promise.then((data) => MsgDeleteFilePermissionResponse.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
