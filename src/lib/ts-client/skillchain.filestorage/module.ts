// Generated by Ignite ignite.com/cli

import { SigningStargateClient, DeliverTxResponse, StdFee } from "@cosmjs/stargate";
import { EncodeObject, GeneratedType, OfflineSigner, Registry } from "@cosmjs/proto-signing";
import { msgTypes } from './registry';
import { IgniteClient } from "../client"
import { MissingWalletError } from "../helpers"
import { Api } from "./rest";
import { MsgUpdateFileRecordResponse } from "./types/skillchain/filestorage/tx";
import { MsgDeleteFilePermissionResponse } from "./types/skillchain/filestorage/tx";
import { GenesisState } from "./types/skillchain/filestorage/genesis";
import { MsgUpdateParamsResponse } from "./types/skillchain/filestorage/tx";
import { MsgCreateFilePermissionResponse } from "./types/skillchain/filestorage/tx";
import { QueryGetFileRecordResponse } from "./types/skillchain/filestorage/query";
import { QueryAllFileRecordRequest } from "./types/skillchain/filestorage/query";
import { QueryGetFilePermissionRequest } from "./types/skillchain/filestorage/query";
import { QueryAllFilePermissionResponse } from "./types/skillchain/filestorage/query";
import { FilePermission } from "./types/skillchain/filestorage/file_permission";
import { QueryAllFilePermissionRequest } from "./types/skillchain/filestorage/query";
import { MsgDeleteFileRecord } from "./types/skillchain/filestorage/tx";
import { MsgCreateFilePermission } from "./types/skillchain/filestorage/tx";
import { Params } from "./types/skillchain/filestorage/params";
import { QueryAllFileRecordResponse } from "./types/skillchain/filestorage/query";
import { MsgUpdateParams } from "./types/skillchain/filestorage/tx";
import { MsgDeleteFilePermission } from "./types/skillchain/filestorage/tx";
import { FileRecord } from "./types/skillchain/filestorage/file_record";
import { QueryParamsResponse } from "./types/skillchain/filestorage/query";
import { MsgUpdateFileRecord } from "./types/skillchain/filestorage/tx";
import { MsgDeleteFileRecordResponse } from "./types/skillchain/filestorage/tx";
import { MsgUpdateFilePermissionResponse } from "./types/skillchain/filestorage/tx";
import { QueryParamsRequest } from "./types/skillchain/filestorage/query";
import { QueryGetFilePermissionResponse } from "./types/skillchain/filestorage/query";
import { MsgUpdateFilePermission } from "./types/skillchain/filestorage/tx";
import { QueryGetFileRecordRequest } from "./types/skillchain/filestorage/query";
import { MsgCreateFileRecord } from "./types/skillchain/filestorage/tx";
import { MsgCreateFileRecordResponse } from "./types/skillchain/filestorage/tx";

import { FilePermission as typeFilePermission} from "./types"
import { FileRecord as typeFileRecord} from "./types"
import { Params as typeParams} from "./types"

export { MsgUpdateFileRecordResponse, MsgDeleteFilePermissionResponse, GenesisState, MsgUpdateParamsResponse, MsgCreateFilePermissionResponse, QueryGetFileRecordResponse, QueryAllFileRecordRequest, QueryGetFilePermissionRequest, QueryAllFilePermissionResponse, FilePermission, QueryAllFilePermissionRequest, MsgDeleteFileRecord, MsgCreateFilePermission, Params, QueryAllFileRecordResponse, MsgUpdateParams, MsgDeleteFilePermission, FileRecord, QueryParamsResponse, MsgUpdateFileRecord, MsgDeleteFileRecordResponse, MsgUpdateFilePermissionResponse, QueryParamsRequest, QueryGetFilePermissionResponse, MsgUpdateFilePermission, QueryGetFileRecordRequest, MsgCreateFileRecord, MsgCreateFileRecordResponse };

type sendMsgUpdateFileRecordResponseParams = {
  value: MsgUpdateFileRecordResponse,
  fee?: StdFee,
  memo?: string
};

type sendMsgDeleteFilePermissionResponseParams = {
  value: MsgDeleteFilePermissionResponse,
  fee?: StdFee,
  memo?: string
};

type sendGenesisStateParams = {
  value: GenesisState,
  fee?: StdFee,
  memo?: string
};

type sendMsgUpdateParamsResponseParams = {
  value: MsgUpdateParamsResponse,
  fee?: StdFee,
  memo?: string
};

type sendMsgCreateFilePermissionResponseParams = {
  value: MsgCreateFilePermissionResponse,
  fee?: StdFee,
  memo?: string
};

type sendQueryGetFileRecordResponseParams = {
  value: QueryGetFileRecordResponse,
  fee?: StdFee,
  memo?: string
};

type sendQueryAllFileRecordRequestParams = {
  value: QueryAllFileRecordRequest,
  fee?: StdFee,
  memo?: string
};

type sendQueryGetFilePermissionRequestParams = {
  value: QueryGetFilePermissionRequest,
  fee?: StdFee,
  memo?: string
};

type sendQueryAllFilePermissionResponseParams = {
  value: QueryAllFilePermissionResponse,
  fee?: StdFee,
  memo?: string
};

type sendFilePermissionParams = {
  value: FilePermission,
  fee?: StdFee,
  memo?: string
};

type sendQueryAllFilePermissionRequestParams = {
  value: QueryAllFilePermissionRequest,
  fee?: StdFee,
  memo?: string
};

type sendMsgDeleteFileRecordParams = {
  value: MsgDeleteFileRecord,
  fee?: StdFee,
  memo?: string
};

type sendMsgCreateFilePermissionParams = {
  value: MsgCreateFilePermission,
  fee?: StdFee,
  memo?: string
};

type sendParamsParams = {
  value: Params,
  fee?: StdFee,
  memo?: string
};

type sendQueryAllFileRecordResponseParams = {
  value: QueryAllFileRecordResponse,
  fee?: StdFee,
  memo?: string
};

type sendMsgUpdateParamsParams = {
  value: MsgUpdateParams,
  fee?: StdFee,
  memo?: string
};

type sendMsgDeleteFilePermissionParams = {
  value: MsgDeleteFilePermission,
  fee?: StdFee,
  memo?: string
};

type sendFileRecordParams = {
  value: FileRecord,
  fee?: StdFee,
  memo?: string
};

type sendQueryParamsResponseParams = {
  value: QueryParamsResponse,
  fee?: StdFee,
  memo?: string
};

type sendMsgUpdateFileRecordParams = {
  value: MsgUpdateFileRecord,
  fee?: StdFee,
  memo?: string
};

type sendMsgDeleteFileRecordResponseParams = {
  value: MsgDeleteFileRecordResponse,
  fee?: StdFee,
  memo?: string
};

type sendMsgUpdateFilePermissionResponseParams = {
  value: MsgUpdateFilePermissionResponse,
  fee?: StdFee,
  memo?: string
};

type sendQueryParamsRequestParams = {
  value: QueryParamsRequest,
  fee?: StdFee,
  memo?: string
};

type sendQueryGetFilePermissionResponseParams = {
  value: QueryGetFilePermissionResponse,
  fee?: StdFee,
  memo?: string
};

type sendMsgUpdateFilePermissionParams = {
  value: MsgUpdateFilePermission,
  fee?: StdFee,
  memo?: string
};

type sendQueryGetFileRecordRequestParams = {
  value: QueryGetFileRecordRequest,
  fee?: StdFee,
  memo?: string
};

type sendMsgCreateFileRecordParams = {
  value: MsgCreateFileRecord,
  fee?: StdFee,
  memo?: string
};

type sendMsgCreateFileRecordResponseParams = {
  value: MsgCreateFileRecordResponse,
  fee?: StdFee,
  memo?: string
};


type msgUpdateFileRecordResponseParams = {
  value: MsgUpdateFileRecordResponse,
};

type msgDeleteFilePermissionResponseParams = {
  value: MsgDeleteFilePermissionResponse,
};

type genesisStateParams = {
  value: GenesisState,
};

type msgUpdateParamsResponseParams = {
  value: MsgUpdateParamsResponse,
};

type msgCreateFilePermissionResponseParams = {
  value: MsgCreateFilePermissionResponse,
};

type queryGetFileRecordResponseParams = {
  value: QueryGetFileRecordResponse,
};

type queryAllFileRecordRequestParams = {
  value: QueryAllFileRecordRequest,
};

type queryGetFilePermissionRequestParams = {
  value: QueryGetFilePermissionRequest,
};

type queryAllFilePermissionResponseParams = {
  value: QueryAllFilePermissionResponse,
};

type filePermissionParams = {
  value: FilePermission,
};

type queryAllFilePermissionRequestParams = {
  value: QueryAllFilePermissionRequest,
};

type msgDeleteFileRecordParams = {
  value: MsgDeleteFileRecord,
};

type msgCreateFilePermissionParams = {
  value: MsgCreateFilePermission,
};

type paramsParams = {
  value: Params,
};

type queryAllFileRecordResponseParams = {
  value: QueryAllFileRecordResponse,
};

type msgUpdateParamsParams = {
  value: MsgUpdateParams,
};

type msgDeleteFilePermissionParams = {
  value: MsgDeleteFilePermission,
};

type fileRecordParams = {
  value: FileRecord,
};

type queryParamsResponseParams = {
  value: QueryParamsResponse,
};

type msgUpdateFileRecordParams = {
  value: MsgUpdateFileRecord,
};

type msgDeleteFileRecordResponseParams = {
  value: MsgDeleteFileRecordResponse,
};

type msgUpdateFilePermissionResponseParams = {
  value: MsgUpdateFilePermissionResponse,
};

type queryParamsRequestParams = {
  value: QueryParamsRequest,
};

type queryGetFilePermissionResponseParams = {
  value: QueryGetFilePermissionResponse,
};

type msgUpdateFilePermissionParams = {
  value: MsgUpdateFilePermission,
};

type queryGetFileRecordRequestParams = {
  value: QueryGetFileRecordRequest,
};

type msgCreateFileRecordParams = {
  value: MsgCreateFileRecord,
};

type msgCreateFileRecordResponseParams = {
  value: MsgCreateFileRecordResponse,
};


export const registry = new Registry(msgTypes);

type Field = {
	name: string;
	type: unknown;
}
function getStructure(template) {
	const structure: {fields: Field[]} = { fields: [] }
	for (let [key, value] of Object.entries(template)) {
		let field = { name: key, type: typeof value }
		structure.fields.push(field)
	}
	return structure
}
const defaultFee = {
  amount: [],
  gas: "200000",
};

interface TxClientOptions {
  addr: string
	prefix: string
	signer?: OfflineSigner
}

export const txClient = ({ signer, prefix, addr }: TxClientOptions = { addr: "http://localhost:26657", prefix: "cosmos" }) => {

  return {
		
		async sendMsgUpdateFileRecordResponse({ value, fee, memo }: sendMsgUpdateFileRecordResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgUpdateFileRecordResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgUpdateFileRecordResponse({ value: MsgUpdateFileRecordResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgUpdateFileRecordResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgDeleteFilePermissionResponse({ value, fee, memo }: sendMsgDeleteFilePermissionResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgDeleteFilePermissionResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgDeleteFilePermissionResponse({ value: MsgDeleteFilePermissionResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgDeleteFilePermissionResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendGenesisState({ value, fee, memo }: sendGenesisStateParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendGenesisState: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.genesisState({ value: GenesisState.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendGenesisState: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgUpdateParamsResponse({ value, fee, memo }: sendMsgUpdateParamsResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgUpdateParamsResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgUpdateParamsResponse({ value: MsgUpdateParamsResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgUpdateParamsResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgCreateFilePermissionResponse({ value, fee, memo }: sendMsgCreateFilePermissionResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgCreateFilePermissionResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgCreateFilePermissionResponse({ value: MsgCreateFilePermissionResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgCreateFilePermissionResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryGetFileRecordResponse({ value, fee, memo }: sendQueryGetFileRecordResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryGetFileRecordResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryGetFileRecordResponse({ value: QueryGetFileRecordResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryGetFileRecordResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryAllFileRecordRequest({ value, fee, memo }: sendQueryAllFileRecordRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryAllFileRecordRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryAllFileRecordRequest({ value: QueryAllFileRecordRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryAllFileRecordRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryGetFilePermissionRequest({ value, fee, memo }: sendQueryGetFilePermissionRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryGetFilePermissionRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryGetFilePermissionRequest({ value: QueryGetFilePermissionRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryGetFilePermissionRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryAllFilePermissionResponse({ value, fee, memo }: sendQueryAllFilePermissionResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryAllFilePermissionResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryAllFilePermissionResponse({ value: QueryAllFilePermissionResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryAllFilePermissionResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendFilePermission({ value, fee, memo }: sendFilePermissionParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendFilePermission: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.filePermission({ value: FilePermission.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendFilePermission: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryAllFilePermissionRequest({ value, fee, memo }: sendQueryAllFilePermissionRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryAllFilePermissionRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryAllFilePermissionRequest({ value: QueryAllFilePermissionRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryAllFilePermissionRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgDeleteFileRecord({ value, fee, memo }: sendMsgDeleteFileRecordParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgDeleteFileRecord: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgDeleteFileRecord({ value: MsgDeleteFileRecord.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgDeleteFileRecord: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgCreateFilePermission({ value, fee, memo }: sendMsgCreateFilePermissionParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgCreateFilePermission: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgCreateFilePermission({ value: MsgCreateFilePermission.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgCreateFilePermission: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendParams({ value, fee, memo }: sendParamsParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendParams: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.params({ value: Params.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendParams: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryAllFileRecordResponse({ value, fee, memo }: sendQueryAllFileRecordResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryAllFileRecordResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryAllFileRecordResponse({ value: QueryAllFileRecordResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryAllFileRecordResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgUpdateParams({ value, fee, memo }: sendMsgUpdateParamsParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgUpdateParams: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgUpdateParams({ value: MsgUpdateParams.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgUpdateParams: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgDeleteFilePermission({ value, fee, memo }: sendMsgDeleteFilePermissionParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgDeleteFilePermission: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgDeleteFilePermission({ value: MsgDeleteFilePermission.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgDeleteFilePermission: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendFileRecord({ value, fee, memo }: sendFileRecordParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendFileRecord: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.fileRecord({ value: FileRecord.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendFileRecord: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryParamsResponse({ value, fee, memo }: sendQueryParamsResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryParamsResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryParamsResponse({ value: QueryParamsResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryParamsResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgUpdateFileRecord({ value, fee, memo }: sendMsgUpdateFileRecordParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgUpdateFileRecord: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgUpdateFileRecord({ value: MsgUpdateFileRecord.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgUpdateFileRecord: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgDeleteFileRecordResponse({ value, fee, memo }: sendMsgDeleteFileRecordResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgDeleteFileRecordResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgDeleteFileRecordResponse({ value: MsgDeleteFileRecordResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgDeleteFileRecordResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgUpdateFilePermissionResponse({ value, fee, memo }: sendMsgUpdateFilePermissionResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgUpdateFilePermissionResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgUpdateFilePermissionResponse({ value: MsgUpdateFilePermissionResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgUpdateFilePermissionResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryParamsRequest({ value, fee, memo }: sendQueryParamsRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryParamsRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryParamsRequest({ value: QueryParamsRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryParamsRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryGetFilePermissionResponse({ value, fee, memo }: sendQueryGetFilePermissionResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryGetFilePermissionResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryGetFilePermissionResponse({ value: QueryGetFilePermissionResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryGetFilePermissionResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgUpdateFilePermission({ value, fee, memo }: sendMsgUpdateFilePermissionParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgUpdateFilePermission: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgUpdateFilePermission({ value: MsgUpdateFilePermission.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgUpdateFilePermission: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryGetFileRecordRequest({ value, fee, memo }: sendQueryGetFileRecordRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryGetFileRecordRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryGetFileRecordRequest({ value: QueryGetFileRecordRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryGetFileRecordRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgCreateFileRecord({ value, fee, memo }: sendMsgCreateFileRecordParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgCreateFileRecord: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgCreateFileRecord({ value: MsgCreateFileRecord.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgCreateFileRecord: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgCreateFileRecordResponse({ value, fee, memo }: sendMsgCreateFileRecordResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgCreateFileRecordResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgCreateFileRecordResponse({ value: MsgCreateFileRecordResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgCreateFileRecordResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		
		msgUpdateFileRecordResponse({ value }: msgUpdateFileRecordResponseParams): EncodeObject {
			try {
				return { typeUrl: "/skillchain.filestorage.MsgUpdateFileRecordResponse", value: MsgUpdateFileRecordResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgUpdateFileRecordResponse: Could not create message: ' + e.message)
			}
		},
		
		msgDeleteFilePermissionResponse({ value }: msgDeleteFilePermissionResponseParams): EncodeObject {
			try {
				return { typeUrl: "/skillchain.filestorage.MsgDeleteFilePermissionResponse", value: MsgDeleteFilePermissionResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgDeleteFilePermissionResponse: Could not create message: ' + e.message)
			}
		},
		
		genesisState({ value }: genesisStateParams): EncodeObject {
			try {
				return { typeUrl: "/skillchain.filestorage.GenesisState", value: GenesisState.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:GenesisState: Could not create message: ' + e.message)
			}
		},
		
		msgUpdateParamsResponse({ value }: msgUpdateParamsResponseParams): EncodeObject {
			try {
				return { typeUrl: "/skillchain.filestorage.MsgUpdateParamsResponse", value: MsgUpdateParamsResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgUpdateParamsResponse: Could not create message: ' + e.message)
			}
		},
		
		msgCreateFilePermissionResponse({ value }: msgCreateFilePermissionResponseParams): EncodeObject {
			try {
				return { typeUrl: "/skillchain.filestorage.MsgCreateFilePermissionResponse", value: MsgCreateFilePermissionResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgCreateFilePermissionResponse: Could not create message: ' + e.message)
			}
		},
		
		queryGetFileRecordResponse({ value }: queryGetFileRecordResponseParams): EncodeObject {
			try {
				return { typeUrl: "/skillchain.filestorage.QueryGetFileRecordResponse", value: QueryGetFileRecordResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryGetFileRecordResponse: Could not create message: ' + e.message)
			}
		},
		
		queryAllFileRecordRequest({ value }: queryAllFileRecordRequestParams): EncodeObject {
			try {
				return { typeUrl: "/skillchain.filestorage.QueryAllFileRecordRequest", value: QueryAllFileRecordRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryAllFileRecordRequest: Could not create message: ' + e.message)
			}
		},
		
		queryGetFilePermissionRequest({ value }: queryGetFilePermissionRequestParams): EncodeObject {
			try {
				return { typeUrl: "/skillchain.filestorage.QueryGetFilePermissionRequest", value: QueryGetFilePermissionRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryGetFilePermissionRequest: Could not create message: ' + e.message)
			}
		},
		
		queryAllFilePermissionResponse({ value }: queryAllFilePermissionResponseParams): EncodeObject {
			try {
				return { typeUrl: "/skillchain.filestorage.QueryAllFilePermissionResponse", value: QueryAllFilePermissionResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryAllFilePermissionResponse: Could not create message: ' + e.message)
			}
		},
		
		filePermission({ value }: filePermissionParams): EncodeObject {
			try {
				return { typeUrl: "/skillchain.filestorage.FilePermission", value: FilePermission.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:FilePermission: Could not create message: ' + e.message)
			}
		},
		
		queryAllFilePermissionRequest({ value }: queryAllFilePermissionRequestParams): EncodeObject {
			try {
				return { typeUrl: "/skillchain.filestorage.QueryAllFilePermissionRequest", value: QueryAllFilePermissionRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryAllFilePermissionRequest: Could not create message: ' + e.message)
			}
		},
		
		msgDeleteFileRecord({ value }: msgDeleteFileRecordParams): EncodeObject {
			try {
				return { typeUrl: "/skillchain.filestorage.MsgDeleteFileRecord", value: MsgDeleteFileRecord.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgDeleteFileRecord: Could not create message: ' + e.message)
			}
		},
		
		msgCreateFilePermission({ value }: msgCreateFilePermissionParams): EncodeObject {
			try {
				return { typeUrl: "/skillchain.filestorage.MsgCreateFilePermission", value: MsgCreateFilePermission.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgCreateFilePermission: Could not create message: ' + e.message)
			}
		},
		
		params({ value }: paramsParams): EncodeObject {
			try {
				return { typeUrl: "/skillchain.filestorage.Params", value: Params.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:Params: Could not create message: ' + e.message)
			}
		},
		
		queryAllFileRecordResponse({ value }: queryAllFileRecordResponseParams): EncodeObject {
			try {
				return { typeUrl: "/skillchain.filestorage.QueryAllFileRecordResponse", value: QueryAllFileRecordResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryAllFileRecordResponse: Could not create message: ' + e.message)
			}
		},
		
		msgUpdateParams({ value }: msgUpdateParamsParams): EncodeObject {
			try {
				return { typeUrl: "/skillchain.filestorage.MsgUpdateParams", value: MsgUpdateParams.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgUpdateParams: Could not create message: ' + e.message)
			}
		},
		
		msgDeleteFilePermission({ value }: msgDeleteFilePermissionParams): EncodeObject {
			try {
				return { typeUrl: "/skillchain.filestorage.MsgDeleteFilePermission", value: MsgDeleteFilePermission.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgDeleteFilePermission: Could not create message: ' + e.message)
			}
		},
		
		fileRecord({ value }: fileRecordParams): EncodeObject {
			try {
				return { typeUrl: "/skillchain.filestorage.FileRecord", value: FileRecord.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:FileRecord: Could not create message: ' + e.message)
			}
		},
		
		queryParamsResponse({ value }: queryParamsResponseParams): EncodeObject {
			try {
				return { typeUrl: "/skillchain.filestorage.QueryParamsResponse", value: QueryParamsResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryParamsResponse: Could not create message: ' + e.message)
			}
		},
		
		msgUpdateFileRecord({ value }: msgUpdateFileRecordParams): EncodeObject {
			try {
				return { typeUrl: "/skillchain.filestorage.MsgUpdateFileRecord", value: MsgUpdateFileRecord.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgUpdateFileRecord: Could not create message: ' + e.message)
			}
		},
		
		msgDeleteFileRecordResponse({ value }: msgDeleteFileRecordResponseParams): EncodeObject {
			try {
				return { typeUrl: "/skillchain.filestorage.MsgDeleteFileRecordResponse", value: MsgDeleteFileRecordResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgDeleteFileRecordResponse: Could not create message: ' + e.message)
			}
		},
		
		msgUpdateFilePermissionResponse({ value }: msgUpdateFilePermissionResponseParams): EncodeObject {
			try {
				return { typeUrl: "/skillchain.filestorage.MsgUpdateFilePermissionResponse", value: MsgUpdateFilePermissionResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgUpdateFilePermissionResponse: Could not create message: ' + e.message)
			}
		},
		
		queryParamsRequest({ value }: queryParamsRequestParams): EncodeObject {
			try {
				return { typeUrl: "/skillchain.filestorage.QueryParamsRequest", value: QueryParamsRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryParamsRequest: Could not create message: ' + e.message)
			}
		},
		
		queryGetFilePermissionResponse({ value }: queryGetFilePermissionResponseParams): EncodeObject {
			try {
				return { typeUrl: "/skillchain.filestorage.QueryGetFilePermissionResponse", value: QueryGetFilePermissionResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryGetFilePermissionResponse: Could not create message: ' + e.message)
			}
		},
		
		msgUpdateFilePermission({ value }: msgUpdateFilePermissionParams): EncodeObject {
			try {
				return { typeUrl: "/skillchain.filestorage.MsgUpdateFilePermission", value: MsgUpdateFilePermission.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgUpdateFilePermission: Could not create message: ' + e.message)
			}
		},
		
		queryGetFileRecordRequest({ value }: queryGetFileRecordRequestParams): EncodeObject {
			try {
				return { typeUrl: "/skillchain.filestorage.QueryGetFileRecordRequest", value: QueryGetFileRecordRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryGetFileRecordRequest: Could not create message: ' + e.message)
			}
		},
		
		msgCreateFileRecord({ value }: msgCreateFileRecordParams): EncodeObject {
			try {
				return { typeUrl: "/skillchain.filestorage.MsgCreateFileRecord", value: MsgCreateFileRecord.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgCreateFileRecord: Could not create message: ' + e.message)
			}
		},
		
		msgCreateFileRecordResponse({ value }: msgCreateFileRecordResponseParams): EncodeObject {
			try {
				return { typeUrl: "/skillchain.filestorage.MsgCreateFileRecordResponse", value: MsgCreateFileRecordResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgCreateFileRecordResponse: Could not create message: ' + e.message)
			}
		},
		
	}
};

interface QueryClientOptions {
  addr: string
}

export const queryClient = ({ addr: addr }: QueryClientOptions = { addr: "http://localhost:1317" }) => {
  return new Api({ baseURL: addr });
};

class SDKModule {
	public query: ReturnType<typeof queryClient>;
	public tx: ReturnType<typeof txClient>;
	public structure: Record<string,unknown>;
	public registry: Array<[string, GeneratedType]> = [];

	constructor(client: IgniteClient) {		
	
		this.query = queryClient({ addr: client.env.apiURL });		
		this.updateTX(client);
		this.structure =  {
						FilePermission: getStructure(typeFilePermission.fromPartial({})),
						FileRecord: getStructure(typeFileRecord.fromPartial({})),
						Params: getStructure(typeParams.fromPartial({})),
						
		};
		client.on('signer-changed',(signer) => {			
		 this.updateTX(client);
		})
	}
	updateTX(client: IgniteClient) {
    const methods = txClient({
        signer: client.signer,
        addr: client.env.rpcURL,
        prefix: client.env.prefix ?? "cosmos",
    })
	
    this.tx = methods;
    for (let m in methods) {
        this.tx[m] = methods[m].bind(this.tx);
    }
	}
};

const IgntModule = (test: IgniteClient) => {
	return {
		module: {
			SkillchainFilestorage: new SDKModule(test)
		},
		registry: msgTypes
  }
}
export default IgntModule;