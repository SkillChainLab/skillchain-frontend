// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               unknown
// source: skillchain/skillchain/query.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Params } from "./params";

export const protobufPackage = "skillchain.skillchain";

/** QueryParamsRequest is request type for the Query/Params RPC method. */
export interface QueryParamsRequest {
}

/** QueryParamsResponse is response type for the Query/Params RPC method. */
export interface QueryParamsResponse {
  /** params holds all the parameters of this module. */
  params: Params | undefined;
}

export interface QueryTokenInfoRequest {
}

export interface QueryTokenInfoResponse {
  name: string;
  symbol: string;
  decimals: number;
  description: string;
  totalSupply: string;
  circulatingSupply: string;
  burnedAmount: string;
  maxSupply: string;
  burnEnabled: boolean;
  chainDescription: string;
  websiteUrl: string;
}

export interface QueryVUSDTreasuryRequest {
}

export interface QueryVUSDTreasuryResponse {
  skillBalance: string;
  vusdSupply: string;
  exchangeRate: string;
}

export interface QueryUserVUSDPositionRequest {
  address: string;
}

export interface QueryUserVUSDPositionResponse {
  vusdBalance: string;
  skillCollateral: string;
  healthFactor: string;
  position: string;
  exists: boolean;
}

function createBaseQueryParamsRequest(): QueryParamsRequest {
  return {};
}

export const QueryParamsRequest: MessageFns<QueryParamsRequest> = {
  encode(_: QueryParamsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryParamsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryParamsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): QueryParamsRequest {
    return {};
  },

  toJSON(_: QueryParamsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryParamsRequest>, I>>(base?: I): QueryParamsRequest {
    return QueryParamsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryParamsRequest>, I>>(_: I): QueryParamsRequest {
    const message = createBaseQueryParamsRequest();
    return message;
  },
};

function createBaseQueryParamsResponse(): QueryParamsResponse {
  return { params: undefined };
}

export const QueryParamsResponse: MessageFns<QueryParamsResponse> = {
  encode(message: QueryParamsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.params !== undefined) {
      Params.encode(message.params, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryParamsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryParamsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.params = Params.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryParamsResponse {
    return { params: isSet(object.params) ? Params.fromJSON(object.params) : undefined };
  },

  toJSON(message: QueryParamsResponse): unknown {
    const obj: any = {};
    if (message.params !== undefined) {
      obj.params = Params.toJSON(message.params);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryParamsResponse>, I>>(base?: I): QueryParamsResponse {
    return QueryParamsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryParamsResponse>, I>>(object: I): QueryParamsResponse {
    const message = createBaseQueryParamsResponse();
    message.params = (object.params !== undefined && object.params !== null)
      ? Params.fromPartial(object.params)
      : undefined;
    return message;
  },
};

function createBaseQueryTokenInfoRequest(): QueryTokenInfoRequest {
  return {};
}

export const QueryTokenInfoRequest: MessageFns<QueryTokenInfoRequest> = {
  encode(_: QueryTokenInfoRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryTokenInfoRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryTokenInfoRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): QueryTokenInfoRequest {
    return {};
  },

  toJSON(_: QueryTokenInfoRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryTokenInfoRequest>, I>>(base?: I): QueryTokenInfoRequest {
    return QueryTokenInfoRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryTokenInfoRequest>, I>>(_: I): QueryTokenInfoRequest {
    const message = createBaseQueryTokenInfoRequest();
    return message;
  },
};

function createBaseQueryTokenInfoResponse(): QueryTokenInfoResponse {
  return {
    name: "",
    symbol: "",
    decimals: 0,
    description: "",
    totalSupply: "",
    circulatingSupply: "",
    burnedAmount: "",
    maxSupply: "",
    burnEnabled: false,
    chainDescription: "",
    websiteUrl: "",
  };
}

export const QueryTokenInfoResponse: MessageFns<QueryTokenInfoResponse> = {
  encode(message: QueryTokenInfoResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.symbol !== "") {
      writer.uint32(18).string(message.symbol);
    }
    if (message.decimals !== 0) {
      writer.uint32(24).uint32(message.decimals);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    if (message.totalSupply !== "") {
      writer.uint32(42).string(message.totalSupply);
    }
    if (message.circulatingSupply !== "") {
      writer.uint32(50).string(message.circulatingSupply);
    }
    if (message.burnedAmount !== "") {
      writer.uint32(58).string(message.burnedAmount);
    }
    if (message.maxSupply !== "") {
      writer.uint32(66).string(message.maxSupply);
    }
    if (message.burnEnabled !== false) {
      writer.uint32(72).bool(message.burnEnabled);
    }
    if (message.chainDescription !== "") {
      writer.uint32(82).string(message.chainDescription);
    }
    if (message.websiteUrl !== "") {
      writer.uint32(90).string(message.websiteUrl);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryTokenInfoResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryTokenInfoResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.symbol = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.decimals = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.totalSupply = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.circulatingSupply = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.burnedAmount = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.maxSupply = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.burnEnabled = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.chainDescription = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.websiteUrl = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryTokenInfoResponse {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      symbol: isSet(object.symbol) ? globalThis.String(object.symbol) : "",
      decimals: isSet(object.decimals) ? globalThis.Number(object.decimals) : 0,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      totalSupply: isSet(object.totalSupply) ? globalThis.String(object.totalSupply) : "",
      circulatingSupply: isSet(object.circulatingSupply) ? globalThis.String(object.circulatingSupply) : "",
      burnedAmount: isSet(object.burnedAmount) ? globalThis.String(object.burnedAmount) : "",
      maxSupply: isSet(object.maxSupply) ? globalThis.String(object.maxSupply) : "",
      burnEnabled: isSet(object.burnEnabled) ? globalThis.Boolean(object.burnEnabled) : false,
      chainDescription: isSet(object.chainDescription) ? globalThis.String(object.chainDescription) : "",
      websiteUrl: isSet(object.websiteUrl) ? globalThis.String(object.websiteUrl) : "",
    };
  },

  toJSON(message: QueryTokenInfoResponse): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.symbol !== "") {
      obj.symbol = message.symbol;
    }
    if (message.decimals !== 0) {
      obj.decimals = Math.round(message.decimals);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.totalSupply !== "") {
      obj.totalSupply = message.totalSupply;
    }
    if (message.circulatingSupply !== "") {
      obj.circulatingSupply = message.circulatingSupply;
    }
    if (message.burnedAmount !== "") {
      obj.burnedAmount = message.burnedAmount;
    }
    if (message.maxSupply !== "") {
      obj.maxSupply = message.maxSupply;
    }
    if (message.burnEnabled !== false) {
      obj.burnEnabled = message.burnEnabled;
    }
    if (message.chainDescription !== "") {
      obj.chainDescription = message.chainDescription;
    }
    if (message.websiteUrl !== "") {
      obj.websiteUrl = message.websiteUrl;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryTokenInfoResponse>, I>>(base?: I): QueryTokenInfoResponse {
    return QueryTokenInfoResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryTokenInfoResponse>, I>>(object: I): QueryTokenInfoResponse {
    const message = createBaseQueryTokenInfoResponse();
    message.name = object.name ?? "";
    message.symbol = object.symbol ?? "";
    message.decimals = object.decimals ?? 0;
    message.description = object.description ?? "";
    message.totalSupply = object.totalSupply ?? "";
    message.circulatingSupply = object.circulatingSupply ?? "";
    message.burnedAmount = object.burnedAmount ?? "";
    message.maxSupply = object.maxSupply ?? "";
    message.burnEnabled = object.burnEnabled ?? false;
    message.chainDescription = object.chainDescription ?? "";
    message.websiteUrl = object.websiteUrl ?? "";
    return message;
  },
};

function createBaseQueryVUSDTreasuryRequest(): QueryVUSDTreasuryRequest {
  return {};
}

export const QueryVUSDTreasuryRequest: MessageFns<QueryVUSDTreasuryRequest> = {
  encode(_: QueryVUSDTreasuryRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryVUSDTreasuryRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryVUSDTreasuryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): QueryVUSDTreasuryRequest {
    return {};
  },

  toJSON(_: QueryVUSDTreasuryRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryVUSDTreasuryRequest>, I>>(base?: I): QueryVUSDTreasuryRequest {
    return QueryVUSDTreasuryRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryVUSDTreasuryRequest>, I>>(_: I): QueryVUSDTreasuryRequest {
    const message = createBaseQueryVUSDTreasuryRequest();
    return message;
  },
};

function createBaseQueryVUSDTreasuryResponse(): QueryVUSDTreasuryResponse {
  return { skillBalance: "", vusdSupply: "", exchangeRate: "" };
}

export const QueryVUSDTreasuryResponse: MessageFns<QueryVUSDTreasuryResponse> = {
  encode(message: QueryVUSDTreasuryResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.skillBalance !== "") {
      writer.uint32(10).string(message.skillBalance);
    }
    if (message.vusdSupply !== "") {
      writer.uint32(18).string(message.vusdSupply);
    }
    if (message.exchangeRate !== "") {
      writer.uint32(26).string(message.exchangeRate);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryVUSDTreasuryResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryVUSDTreasuryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.skillBalance = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.vusdSupply = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.exchangeRate = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryVUSDTreasuryResponse {
    return {
      skillBalance: isSet(object.skillBalance) ? globalThis.String(object.skillBalance) : "",
      vusdSupply: isSet(object.vusdSupply) ? globalThis.String(object.vusdSupply) : "",
      exchangeRate: isSet(object.exchangeRate) ? globalThis.String(object.exchangeRate) : "",
    };
  },

  toJSON(message: QueryVUSDTreasuryResponse): unknown {
    const obj: any = {};
    if (message.skillBalance !== "") {
      obj.skillBalance = message.skillBalance;
    }
    if (message.vusdSupply !== "") {
      obj.vusdSupply = message.vusdSupply;
    }
    if (message.exchangeRate !== "") {
      obj.exchangeRate = message.exchangeRate;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryVUSDTreasuryResponse>, I>>(base?: I): QueryVUSDTreasuryResponse {
    return QueryVUSDTreasuryResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryVUSDTreasuryResponse>, I>>(object: I): QueryVUSDTreasuryResponse {
    const message = createBaseQueryVUSDTreasuryResponse();
    message.skillBalance = object.skillBalance ?? "";
    message.vusdSupply = object.vusdSupply ?? "";
    message.exchangeRate = object.exchangeRate ?? "";
    return message;
  },
};

function createBaseQueryUserVUSDPositionRequest(): QueryUserVUSDPositionRequest {
  return { address: "" };
}

export const QueryUserVUSDPositionRequest: MessageFns<QueryUserVUSDPositionRequest> = {
  encode(message: QueryUserVUSDPositionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryUserVUSDPositionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryUserVUSDPositionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryUserVUSDPositionRequest {
    return { address: isSet(object.address) ? globalThis.String(object.address) : "" };
  },

  toJSON(message: QueryUserVUSDPositionRequest): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryUserVUSDPositionRequest>, I>>(base?: I): QueryUserVUSDPositionRequest {
    return QueryUserVUSDPositionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryUserVUSDPositionRequest>, I>>(object: I): QueryUserVUSDPositionRequest {
    const message = createBaseQueryUserVUSDPositionRequest();
    message.address = object.address ?? "";
    return message;
  },
};

function createBaseQueryUserVUSDPositionResponse(): QueryUserVUSDPositionResponse {
  return { vusdBalance: "", skillCollateral: "", healthFactor: "", position: "", exists: false };
}

export const QueryUserVUSDPositionResponse: MessageFns<QueryUserVUSDPositionResponse> = {
  encode(message: QueryUserVUSDPositionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.vusdBalance !== "") {
      writer.uint32(10).string(message.vusdBalance);
    }
    if (message.skillCollateral !== "") {
      writer.uint32(18).string(message.skillCollateral);
    }
    if (message.healthFactor !== "") {
      writer.uint32(26).string(message.healthFactor);
    }
    if (message.position !== "") {
      writer.uint32(34).string(message.position);
    }
    if (message.exists !== false) {
      writer.uint32(40).bool(message.exists);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryUserVUSDPositionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryUserVUSDPositionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.vusdBalance = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.skillCollateral = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.healthFactor = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.position = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.exists = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryUserVUSDPositionResponse {
    return {
      vusdBalance: isSet(object.vusdBalance) ? globalThis.String(object.vusdBalance) : "",
      skillCollateral: isSet(object.skillCollateral) ? globalThis.String(object.skillCollateral) : "",
      healthFactor: isSet(object.healthFactor) ? globalThis.String(object.healthFactor) : "",
      position: isSet(object.position) ? globalThis.String(object.position) : "",
      exists: isSet(object.exists) ? globalThis.Boolean(object.exists) : false,
    };
  },

  toJSON(message: QueryUserVUSDPositionResponse): unknown {
    const obj: any = {};
    if (message.vusdBalance !== "") {
      obj.vusdBalance = message.vusdBalance;
    }
    if (message.skillCollateral !== "") {
      obj.skillCollateral = message.skillCollateral;
    }
    if (message.healthFactor !== "") {
      obj.healthFactor = message.healthFactor;
    }
    if (message.position !== "") {
      obj.position = message.position;
    }
    if (message.exists !== false) {
      obj.exists = message.exists;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryUserVUSDPositionResponse>, I>>(base?: I): QueryUserVUSDPositionResponse {
    return QueryUserVUSDPositionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryUserVUSDPositionResponse>, I>>(
    object: I,
  ): QueryUserVUSDPositionResponse {
    const message = createBaseQueryUserVUSDPositionResponse();
    message.vusdBalance = object.vusdBalance ?? "";
    message.skillCollateral = object.skillCollateral ?? "";
    message.healthFactor = object.healthFactor ?? "";
    message.position = object.position ?? "";
    message.exists = object.exists ?? false;
    return message;
  },
};

/** Query defines the gRPC querier service. */
export interface Query {
  /** Parameters queries the parameters of the module. */
  Params(request: QueryParamsRequest): Promise<QueryParamsResponse>;
  TokenInfo(request: QueryTokenInfoRequest): Promise<QueryTokenInfoResponse>;
  VUSDTreasury(request: QueryVUSDTreasuryRequest): Promise<QueryVUSDTreasuryResponse>;
  UserVUSDPosition(request: QueryUserVUSDPositionRequest): Promise<QueryUserVUSDPositionResponse>;
}

export const QueryServiceName = "skillchain.skillchain.Query";
export class QueryClientImpl implements Query {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || QueryServiceName;
    this.rpc = rpc;
    this.Params = this.Params.bind(this);
    this.TokenInfo = this.TokenInfo.bind(this);
    this.VUSDTreasury = this.VUSDTreasury.bind(this);
    this.UserVUSDPosition = this.UserVUSDPosition.bind(this);
  }
  Params(request: QueryParamsRequest): Promise<QueryParamsResponse> {
    const data = QueryParamsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Params", data);
    return promise.then((data) => QueryParamsResponse.decode(new BinaryReader(data)));
  }

  TokenInfo(request: QueryTokenInfoRequest): Promise<QueryTokenInfoResponse> {
    const data = QueryTokenInfoRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "TokenInfo", data);
    return promise.then((data) => QueryTokenInfoResponse.decode(new BinaryReader(data)));
  }

  VUSDTreasury(request: QueryVUSDTreasuryRequest): Promise<QueryVUSDTreasuryResponse> {
    const data = QueryVUSDTreasuryRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "VUSDTreasury", data);
    return promise.then((data) => QueryVUSDTreasuryResponse.decode(new BinaryReader(data)));
  }

  UserVUSDPosition(request: QueryUserVUSDPositionRequest): Promise<QueryUserVUSDPositionResponse> {
    const data = QueryUserVUSDPositionRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "UserVUSDPosition", data);
    return promise.then((data) => QueryUserVUSDPositionResponse.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
