// Generated by Ignite ignite.com/cli

import { SigningStargateClient, DeliverTxResponse, StdFee } from "@cosmjs/stargate";
import { EncodeObject, GeneratedType, OfflineSigner, Registry } from "@cosmjs/proto-signing";
import { msgTypes } from './registry';
import { IgniteClient } from "../client"
import { MissingWalletError } from "../helpers"
import { Api } from "./rest";
import { QueryListJobPostingsResponse } from "./types/skillchain/marketplace/query";
import { MsgCreateProject } from "./types/skillchain/marketplace/tx";
import { MsgDeleteProposalResponse } from "./types/skillchain/marketplace/tx";
import { MsgUpdateMilestone } from "./types/skillchain/marketplace/tx";
import { MsgDeleteMilestoneResponse } from "./types/skillchain/marketplace/tx";
import { MsgCompleteMilestoneResponse } from "./types/skillchain/marketplace/tx";
import { MsgDisputeProject } from "./types/skillchain/marketplace/tx";
import { MsgCreateProjectResponse } from "./types/skillchain/marketplace/tx";
import { QueryAllMilestoneResponse } from "./types/skillchain/marketplace/query";
import { MsgUpdateJobPostingResponse } from "./types/skillchain/marketplace/tx";
import { QueryListJobPostingsRequest } from "./types/skillchain/marketplace/query";
import { QueryListProposalsRequest } from "./types/skillchain/marketplace/query";
import { MsgCreateJobPostingResponse } from "./types/skillchain/marketplace/tx";
import { MsgDeleteJobPostingResponse } from "./types/skillchain/marketplace/tx";
import { MsgReleasePayment } from "./types/skillchain/marketplace/tx";
import { QueryAllJobPostingResponse } from "./types/skillchain/marketplace/query";
import { QueryGetProposalRequest } from "./types/skillchain/marketplace/query";
import { Project } from "./types/skillchain/marketplace/project";
import { MsgUpdateMilestoneResponse } from "./types/skillchain/marketplace/tx";
import { Params } from "./types/skillchain/marketplace/params";
import { QueryGetJobPostingResponse } from "./types/skillchain/marketplace/query";
import { QueryListProjectsResponse } from "./types/skillchain/marketplace/query";
import { MsgUpdateParams } from "./types/skillchain/marketplace/tx";
import { MsgUpdateProjectResponse } from "./types/skillchain/marketplace/tx";
import { QueryAllProposalRequest } from "./types/skillchain/marketplace/query";
import { MsgUpdateParamsResponse } from "./types/skillchain/marketplace/tx";
import { MsgCreateJobPosting } from "./types/skillchain/marketplace/tx";
import { MsgDeleteProjectResponse } from "./types/skillchain/marketplace/tx";
import { MsgCreateMilestone } from "./types/skillchain/marketplace/tx";
import { MsgDeleteMilestone } from "./types/skillchain/marketplace/tx";
import { GenesisState } from "./types/skillchain/marketplace/genesis";
import { QueryGetProjectRequest } from "./types/skillchain/marketplace/query";
import { Proposal } from "./types/skillchain/marketplace/proposal";
import { MsgUpdateProposal } from "./types/skillchain/marketplace/tx";
import { QueryAllJobPostingRequest } from "./types/skillchain/marketplace/query";
import { MsgUpdateProposalResponse } from "./types/skillchain/marketplace/tx";
import { QueryAllProjectRequest } from "./types/skillchain/marketplace/query";
import { QueryGetMilestoneRequest } from "./types/skillchain/marketplace/query";
import { QueryGetMilestoneResponse } from "./types/skillchain/marketplace/query";
import { QueryListProposalsResponse } from "./types/skillchain/marketplace/query";
import { QueryListProjectsRequest } from "./types/skillchain/marketplace/query";
import { MsgCreateProposal } from "./types/skillchain/marketplace/tx";
import { MsgDeleteProposal } from "./types/skillchain/marketplace/tx";
import { MsgReleasePaymentResponse } from "./types/skillchain/marketplace/tx";
import { QueryParamsResponse } from "./types/skillchain/marketplace/query";
import { QueryGetProjectResponse } from "./types/skillchain/marketplace/query";
import { MsgDeleteJobPosting } from "./types/skillchain/marketplace/tx";
import { MsgCreateMilestoneResponse } from "./types/skillchain/marketplace/tx";
import { MsgAcceptProposalResponse } from "./types/skillchain/marketplace/tx";
import { QueryAllProjectResponse } from "./types/skillchain/marketplace/query";
import { QueryAllMilestoneRequest } from "./types/skillchain/marketplace/query";
import { MsgCreateProposalResponse } from "./types/skillchain/marketplace/tx";
import { JobPosting } from "./types/skillchain/marketplace/job_posting";
import { MsgDeleteProject } from "./types/skillchain/marketplace/tx";
import { QueryGetProposalResponse } from "./types/skillchain/marketplace/query";
import { QueryAllProposalResponse } from "./types/skillchain/marketplace/query";
import { MsgUpdateProject } from "./types/skillchain/marketplace/tx";
import { Milestone } from "./types/skillchain/marketplace/milestone";
import { MsgCompleteMilestone } from "./types/skillchain/marketplace/tx";
import { MsgDisputeProjectResponse } from "./types/skillchain/marketplace/tx";
import { QueryParamsRequest } from "./types/skillchain/marketplace/query";
import { QueryGetJobPostingRequest } from "./types/skillchain/marketplace/query";
import { MsgUpdateJobPosting } from "./types/skillchain/marketplace/tx";
import { MsgAcceptProposal } from "./types/skillchain/marketplace/tx";

import { JobPosting as typeJobPosting} from "./types"
import { Milestone as typeMilestone} from "./types"
import { Params as typeParams} from "./types"
import { Project as typeProject} from "./types"
import { Proposal as typeProposal} from "./types"

export { QueryListJobPostingsResponse, MsgCreateProject, MsgDeleteProposalResponse, MsgUpdateMilestone, MsgDeleteMilestoneResponse, MsgCompleteMilestoneResponse, MsgDisputeProject, MsgCreateProjectResponse, QueryAllMilestoneResponse, MsgUpdateJobPostingResponse, QueryListJobPostingsRequest, QueryListProposalsRequest, MsgCreateJobPostingResponse, MsgDeleteJobPostingResponse, MsgReleasePayment, QueryAllJobPostingResponse, QueryGetProposalRequest, Project, MsgUpdateMilestoneResponse, Params, QueryGetJobPostingResponse, QueryListProjectsResponse, MsgUpdateParams, MsgUpdateProjectResponse, QueryAllProposalRequest, MsgUpdateParamsResponse, MsgCreateJobPosting, MsgDeleteProjectResponse, MsgCreateMilestone, MsgDeleteMilestone, GenesisState, QueryGetProjectRequest, Proposal, MsgUpdateProposal, QueryAllJobPostingRequest, MsgUpdateProposalResponse, QueryAllProjectRequest, QueryGetMilestoneRequest, QueryGetMilestoneResponse, QueryListProposalsResponse, QueryListProjectsRequest, MsgCreateProposal, MsgDeleteProposal, MsgReleasePaymentResponse, QueryParamsResponse, QueryGetProjectResponse, MsgDeleteJobPosting, MsgCreateMilestoneResponse, MsgAcceptProposalResponse, QueryAllProjectResponse, QueryAllMilestoneRequest, MsgCreateProposalResponse, JobPosting, MsgDeleteProject, QueryGetProposalResponse, QueryAllProposalResponse, MsgUpdateProject, Milestone, MsgCompleteMilestone, MsgDisputeProjectResponse, QueryParamsRequest, QueryGetJobPostingRequest, MsgUpdateJobPosting, MsgAcceptProposal };

type sendQueryListJobPostingsResponseParams = {
  value: QueryListJobPostingsResponse,
  fee?: StdFee,
  memo?: string
};

type sendMsgCreateProjectParams = {
  value: MsgCreateProject,
  fee?: StdFee,
  memo?: string
};

type sendMsgDeleteProposalResponseParams = {
  value: MsgDeleteProposalResponse,
  fee?: StdFee,
  memo?: string
};

type sendMsgUpdateMilestoneParams = {
  value: MsgUpdateMilestone,
  fee?: StdFee,
  memo?: string
};

type sendMsgDeleteMilestoneResponseParams = {
  value: MsgDeleteMilestoneResponse,
  fee?: StdFee,
  memo?: string
};

type sendMsgCompleteMilestoneResponseParams = {
  value: MsgCompleteMilestoneResponse,
  fee?: StdFee,
  memo?: string
};

type sendMsgDisputeProjectParams = {
  value: MsgDisputeProject,
  fee?: StdFee,
  memo?: string
};

type sendMsgCreateProjectResponseParams = {
  value: MsgCreateProjectResponse,
  fee?: StdFee,
  memo?: string
};

type sendQueryAllMilestoneResponseParams = {
  value: QueryAllMilestoneResponse,
  fee?: StdFee,
  memo?: string
};

type sendMsgUpdateJobPostingResponseParams = {
  value: MsgUpdateJobPostingResponse,
  fee?: StdFee,
  memo?: string
};

type sendQueryListJobPostingsRequestParams = {
  value: QueryListJobPostingsRequest,
  fee?: StdFee,
  memo?: string
};

type sendQueryListProposalsRequestParams = {
  value: QueryListProposalsRequest,
  fee?: StdFee,
  memo?: string
};

type sendMsgCreateJobPostingResponseParams = {
  value: MsgCreateJobPostingResponse,
  fee?: StdFee,
  memo?: string
};

type sendMsgDeleteJobPostingResponseParams = {
  value: MsgDeleteJobPostingResponse,
  fee?: StdFee,
  memo?: string
};

type sendMsgReleasePaymentParams = {
  value: MsgReleasePayment,
  fee?: StdFee,
  memo?: string
};

type sendQueryAllJobPostingResponseParams = {
  value: QueryAllJobPostingResponse,
  fee?: StdFee,
  memo?: string
};

type sendQueryGetProposalRequestParams = {
  value: QueryGetProposalRequest,
  fee?: StdFee,
  memo?: string
};

type sendProjectParams = {
  value: Project,
  fee?: StdFee,
  memo?: string
};

type sendMsgUpdateMilestoneResponseParams = {
  value: MsgUpdateMilestoneResponse,
  fee?: StdFee,
  memo?: string
};

type sendParamsParams = {
  value: Params,
  fee?: StdFee,
  memo?: string
};

type sendQueryGetJobPostingResponseParams = {
  value: QueryGetJobPostingResponse,
  fee?: StdFee,
  memo?: string
};

type sendQueryListProjectsResponseParams = {
  value: QueryListProjectsResponse,
  fee?: StdFee,
  memo?: string
};

type sendMsgUpdateParamsParams = {
  value: MsgUpdateParams,
  fee?: StdFee,
  memo?: string
};

type sendMsgUpdateProjectResponseParams = {
  value: MsgUpdateProjectResponse,
  fee?: StdFee,
  memo?: string
};

type sendQueryAllProposalRequestParams = {
  value: QueryAllProposalRequest,
  fee?: StdFee,
  memo?: string
};

type sendMsgUpdateParamsResponseParams = {
  value: MsgUpdateParamsResponse,
  fee?: StdFee,
  memo?: string
};

type sendMsgCreateJobPostingParams = {
  value: MsgCreateJobPosting,
  fee?: StdFee,
  memo?: string
};

type sendMsgDeleteProjectResponseParams = {
  value: MsgDeleteProjectResponse,
  fee?: StdFee,
  memo?: string
};

type sendMsgCreateMilestoneParams = {
  value: MsgCreateMilestone,
  fee?: StdFee,
  memo?: string
};

type sendMsgDeleteMilestoneParams = {
  value: MsgDeleteMilestone,
  fee?: StdFee,
  memo?: string
};

type sendGenesisStateParams = {
  value: GenesisState,
  fee?: StdFee,
  memo?: string
};

type sendQueryGetProjectRequestParams = {
  value: QueryGetProjectRequest,
  fee?: StdFee,
  memo?: string
};

type sendProposalParams = {
  value: Proposal,
  fee?: StdFee,
  memo?: string
};

type sendMsgUpdateProposalParams = {
  value: MsgUpdateProposal,
  fee?: StdFee,
  memo?: string
};

type sendQueryAllJobPostingRequestParams = {
  value: QueryAllJobPostingRequest,
  fee?: StdFee,
  memo?: string
};

type sendMsgUpdateProposalResponseParams = {
  value: MsgUpdateProposalResponse,
  fee?: StdFee,
  memo?: string
};

type sendQueryAllProjectRequestParams = {
  value: QueryAllProjectRequest,
  fee?: StdFee,
  memo?: string
};

type sendQueryGetMilestoneRequestParams = {
  value: QueryGetMilestoneRequest,
  fee?: StdFee,
  memo?: string
};

type sendQueryGetMilestoneResponseParams = {
  value: QueryGetMilestoneResponse,
  fee?: StdFee,
  memo?: string
};

type sendQueryListProposalsResponseParams = {
  value: QueryListProposalsResponse,
  fee?: StdFee,
  memo?: string
};

type sendQueryListProjectsRequestParams = {
  value: QueryListProjectsRequest,
  fee?: StdFee,
  memo?: string
};

type sendMsgCreateProposalParams = {
  value: MsgCreateProposal,
  fee?: StdFee,
  memo?: string
};

type sendMsgDeleteProposalParams = {
  value: MsgDeleteProposal,
  fee?: StdFee,
  memo?: string
};

type sendMsgReleasePaymentResponseParams = {
  value: MsgReleasePaymentResponse,
  fee?: StdFee,
  memo?: string
};

type sendQueryParamsResponseParams = {
  value: QueryParamsResponse,
  fee?: StdFee,
  memo?: string
};

type sendQueryGetProjectResponseParams = {
  value: QueryGetProjectResponse,
  fee?: StdFee,
  memo?: string
};

type sendMsgDeleteJobPostingParams = {
  value: MsgDeleteJobPosting,
  fee?: StdFee,
  memo?: string
};

type sendMsgCreateMilestoneResponseParams = {
  value: MsgCreateMilestoneResponse,
  fee?: StdFee,
  memo?: string
};

type sendMsgAcceptProposalResponseParams = {
  value: MsgAcceptProposalResponse,
  fee?: StdFee,
  memo?: string
};

type sendQueryAllProjectResponseParams = {
  value: QueryAllProjectResponse,
  fee?: StdFee,
  memo?: string
};

type sendQueryAllMilestoneRequestParams = {
  value: QueryAllMilestoneRequest,
  fee?: StdFee,
  memo?: string
};

type sendMsgCreateProposalResponseParams = {
  value: MsgCreateProposalResponse,
  fee?: StdFee,
  memo?: string
};

type sendJobPostingParams = {
  value: JobPosting,
  fee?: StdFee,
  memo?: string
};

type sendMsgDeleteProjectParams = {
  value: MsgDeleteProject,
  fee?: StdFee,
  memo?: string
};

type sendQueryGetProposalResponseParams = {
  value: QueryGetProposalResponse,
  fee?: StdFee,
  memo?: string
};

type sendQueryAllProposalResponseParams = {
  value: QueryAllProposalResponse,
  fee?: StdFee,
  memo?: string
};

type sendMsgUpdateProjectParams = {
  value: MsgUpdateProject,
  fee?: StdFee,
  memo?: string
};

type sendMilestoneParams = {
  value: Milestone,
  fee?: StdFee,
  memo?: string
};

type sendMsgCompleteMilestoneParams = {
  value: MsgCompleteMilestone,
  fee?: StdFee,
  memo?: string
};

type sendMsgDisputeProjectResponseParams = {
  value: MsgDisputeProjectResponse,
  fee?: StdFee,
  memo?: string
};

type sendQueryParamsRequestParams = {
  value: QueryParamsRequest,
  fee?: StdFee,
  memo?: string
};

type sendQueryGetJobPostingRequestParams = {
  value: QueryGetJobPostingRequest,
  fee?: StdFee,
  memo?: string
};

type sendMsgUpdateJobPostingParams = {
  value: MsgUpdateJobPosting,
  fee?: StdFee,
  memo?: string
};

type sendMsgAcceptProposalParams = {
  value: MsgAcceptProposal,
  fee?: StdFee,
  memo?: string
};


type queryListJobPostingsResponseParams = {
  value: QueryListJobPostingsResponse,
};

type msgCreateProjectParams = {
  value: MsgCreateProject,
};

type msgDeleteProposalResponseParams = {
  value: MsgDeleteProposalResponse,
};

type msgUpdateMilestoneParams = {
  value: MsgUpdateMilestone,
};

type msgDeleteMilestoneResponseParams = {
  value: MsgDeleteMilestoneResponse,
};

type msgCompleteMilestoneResponseParams = {
  value: MsgCompleteMilestoneResponse,
};

type msgDisputeProjectParams = {
  value: MsgDisputeProject,
};

type msgCreateProjectResponseParams = {
  value: MsgCreateProjectResponse,
};

type queryAllMilestoneResponseParams = {
  value: QueryAllMilestoneResponse,
};

type msgUpdateJobPostingResponseParams = {
  value: MsgUpdateJobPostingResponse,
};

type queryListJobPostingsRequestParams = {
  value: QueryListJobPostingsRequest,
};

type queryListProposalsRequestParams = {
  value: QueryListProposalsRequest,
};

type msgCreateJobPostingResponseParams = {
  value: MsgCreateJobPostingResponse,
};

type msgDeleteJobPostingResponseParams = {
  value: MsgDeleteJobPostingResponse,
};

type msgReleasePaymentParams = {
  value: MsgReleasePayment,
};

type queryAllJobPostingResponseParams = {
  value: QueryAllJobPostingResponse,
};

type queryGetProposalRequestParams = {
  value: QueryGetProposalRequest,
};

type projectParams = {
  value: Project,
};

type msgUpdateMilestoneResponseParams = {
  value: MsgUpdateMilestoneResponse,
};

type paramsParams = {
  value: Params,
};

type queryGetJobPostingResponseParams = {
  value: QueryGetJobPostingResponse,
};

type queryListProjectsResponseParams = {
  value: QueryListProjectsResponse,
};

type msgUpdateParamsParams = {
  value: MsgUpdateParams,
};

type msgUpdateProjectResponseParams = {
  value: MsgUpdateProjectResponse,
};

type queryAllProposalRequestParams = {
  value: QueryAllProposalRequest,
};

type msgUpdateParamsResponseParams = {
  value: MsgUpdateParamsResponse,
};

type msgCreateJobPostingParams = {
  value: MsgCreateJobPosting,
};

type msgDeleteProjectResponseParams = {
  value: MsgDeleteProjectResponse,
};

type msgCreateMilestoneParams = {
  value: MsgCreateMilestone,
};

type msgDeleteMilestoneParams = {
  value: MsgDeleteMilestone,
};

type genesisStateParams = {
  value: GenesisState,
};

type queryGetProjectRequestParams = {
  value: QueryGetProjectRequest,
};

type proposalParams = {
  value: Proposal,
};

type msgUpdateProposalParams = {
  value: MsgUpdateProposal,
};

type queryAllJobPostingRequestParams = {
  value: QueryAllJobPostingRequest,
};

type msgUpdateProposalResponseParams = {
  value: MsgUpdateProposalResponse,
};

type queryAllProjectRequestParams = {
  value: QueryAllProjectRequest,
};

type queryGetMilestoneRequestParams = {
  value: QueryGetMilestoneRequest,
};

type queryGetMilestoneResponseParams = {
  value: QueryGetMilestoneResponse,
};

type queryListProposalsResponseParams = {
  value: QueryListProposalsResponse,
};

type queryListProjectsRequestParams = {
  value: QueryListProjectsRequest,
};

type msgCreateProposalParams = {
  value: MsgCreateProposal,
};

type msgDeleteProposalParams = {
  value: MsgDeleteProposal,
};

type msgReleasePaymentResponseParams = {
  value: MsgReleasePaymentResponse,
};

type queryParamsResponseParams = {
  value: QueryParamsResponse,
};

type queryGetProjectResponseParams = {
  value: QueryGetProjectResponse,
};

type msgDeleteJobPostingParams = {
  value: MsgDeleteJobPosting,
};

type msgCreateMilestoneResponseParams = {
  value: MsgCreateMilestoneResponse,
};

type msgAcceptProposalResponseParams = {
  value: MsgAcceptProposalResponse,
};

type queryAllProjectResponseParams = {
  value: QueryAllProjectResponse,
};

type queryAllMilestoneRequestParams = {
  value: QueryAllMilestoneRequest,
};

type msgCreateProposalResponseParams = {
  value: MsgCreateProposalResponse,
};

type jobPostingParams = {
  value: JobPosting,
};

type msgDeleteProjectParams = {
  value: MsgDeleteProject,
};

type queryGetProposalResponseParams = {
  value: QueryGetProposalResponse,
};

type queryAllProposalResponseParams = {
  value: QueryAllProposalResponse,
};

type msgUpdateProjectParams = {
  value: MsgUpdateProject,
};

type milestoneParams = {
  value: Milestone,
};

type msgCompleteMilestoneParams = {
  value: MsgCompleteMilestone,
};

type msgDisputeProjectResponseParams = {
  value: MsgDisputeProjectResponse,
};

type queryParamsRequestParams = {
  value: QueryParamsRequest,
};

type queryGetJobPostingRequestParams = {
  value: QueryGetJobPostingRequest,
};

type msgUpdateJobPostingParams = {
  value: MsgUpdateJobPosting,
};

type msgAcceptProposalParams = {
  value: MsgAcceptProposal,
};


export const registry = new Registry(msgTypes);

type Field = {
	name: string;
	type: unknown;
}
function getStructure(template) {
	const structure: {fields: Field[]} = { fields: [] }
	for (let [key, value] of Object.entries(template)) {
		let field = { name: key, type: typeof value }
		structure.fields.push(field)
	}
	return structure
}
const defaultFee = {
  amount: [],
  gas: "200000",
};

interface TxClientOptions {
  addr: string
	prefix: string
	signer?: OfflineSigner
}

export const txClient = ({ signer, prefix, addr }: TxClientOptions = { addr: "http://localhost:26657", prefix: "cosmos" }) => {

  return {
		
		async sendQueryListJobPostingsResponse({ value, fee, memo }: sendQueryListJobPostingsResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryListJobPostingsResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryListJobPostingsResponse({ value: QueryListJobPostingsResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryListJobPostingsResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgCreateProject({ value, fee, memo }: sendMsgCreateProjectParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgCreateProject: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgCreateProject({ value: MsgCreateProject.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgCreateProject: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgDeleteProposalResponse({ value, fee, memo }: sendMsgDeleteProposalResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgDeleteProposalResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgDeleteProposalResponse({ value: MsgDeleteProposalResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgDeleteProposalResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgUpdateMilestone({ value, fee, memo }: sendMsgUpdateMilestoneParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgUpdateMilestone: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgUpdateMilestone({ value: MsgUpdateMilestone.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgUpdateMilestone: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgDeleteMilestoneResponse({ value, fee, memo }: sendMsgDeleteMilestoneResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgDeleteMilestoneResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgDeleteMilestoneResponse({ value: MsgDeleteMilestoneResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgDeleteMilestoneResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgCompleteMilestoneResponse({ value, fee, memo }: sendMsgCompleteMilestoneResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgCompleteMilestoneResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgCompleteMilestoneResponse({ value: MsgCompleteMilestoneResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgCompleteMilestoneResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgDisputeProject({ value, fee, memo }: sendMsgDisputeProjectParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgDisputeProject: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgDisputeProject({ value: MsgDisputeProject.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgDisputeProject: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgCreateProjectResponse({ value, fee, memo }: sendMsgCreateProjectResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgCreateProjectResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgCreateProjectResponse({ value: MsgCreateProjectResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgCreateProjectResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryAllMilestoneResponse({ value, fee, memo }: sendQueryAllMilestoneResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryAllMilestoneResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryAllMilestoneResponse({ value: QueryAllMilestoneResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryAllMilestoneResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgUpdateJobPostingResponse({ value, fee, memo }: sendMsgUpdateJobPostingResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgUpdateJobPostingResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgUpdateJobPostingResponse({ value: MsgUpdateJobPostingResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgUpdateJobPostingResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryListJobPostingsRequest({ value, fee, memo }: sendQueryListJobPostingsRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryListJobPostingsRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryListJobPostingsRequest({ value: QueryListJobPostingsRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryListJobPostingsRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryListProposalsRequest({ value, fee, memo }: sendQueryListProposalsRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryListProposalsRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryListProposalsRequest({ value: QueryListProposalsRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryListProposalsRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgCreateJobPostingResponse({ value, fee, memo }: sendMsgCreateJobPostingResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgCreateJobPostingResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgCreateJobPostingResponse({ value: MsgCreateJobPostingResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgCreateJobPostingResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgDeleteJobPostingResponse({ value, fee, memo }: sendMsgDeleteJobPostingResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgDeleteJobPostingResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgDeleteJobPostingResponse({ value: MsgDeleteJobPostingResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgDeleteJobPostingResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgReleasePayment({ value, fee, memo }: sendMsgReleasePaymentParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgReleasePayment: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgReleasePayment({ value: MsgReleasePayment.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgReleasePayment: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryAllJobPostingResponse({ value, fee, memo }: sendQueryAllJobPostingResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryAllJobPostingResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryAllJobPostingResponse({ value: QueryAllJobPostingResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryAllJobPostingResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryGetProposalRequest({ value, fee, memo }: sendQueryGetProposalRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryGetProposalRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryGetProposalRequest({ value: QueryGetProposalRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryGetProposalRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendProject({ value, fee, memo }: sendProjectParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendProject: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.project({ value: Project.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendProject: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgUpdateMilestoneResponse({ value, fee, memo }: sendMsgUpdateMilestoneResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgUpdateMilestoneResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgUpdateMilestoneResponse({ value: MsgUpdateMilestoneResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgUpdateMilestoneResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendParams({ value, fee, memo }: sendParamsParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendParams: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.params({ value: Params.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendParams: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryGetJobPostingResponse({ value, fee, memo }: sendQueryGetJobPostingResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryGetJobPostingResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryGetJobPostingResponse({ value: QueryGetJobPostingResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryGetJobPostingResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryListProjectsResponse({ value, fee, memo }: sendQueryListProjectsResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryListProjectsResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryListProjectsResponse({ value: QueryListProjectsResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryListProjectsResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgUpdateParams({ value, fee, memo }: sendMsgUpdateParamsParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgUpdateParams: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgUpdateParams({ value: MsgUpdateParams.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgUpdateParams: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgUpdateProjectResponse({ value, fee, memo }: sendMsgUpdateProjectResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgUpdateProjectResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgUpdateProjectResponse({ value: MsgUpdateProjectResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgUpdateProjectResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryAllProposalRequest({ value, fee, memo }: sendQueryAllProposalRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryAllProposalRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryAllProposalRequest({ value: QueryAllProposalRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryAllProposalRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgUpdateParamsResponse({ value, fee, memo }: sendMsgUpdateParamsResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgUpdateParamsResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgUpdateParamsResponse({ value: MsgUpdateParamsResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgUpdateParamsResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgCreateJobPosting({ value, fee, memo }: sendMsgCreateJobPostingParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgCreateJobPosting: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgCreateJobPosting({ value: MsgCreateJobPosting.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgCreateJobPosting: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgDeleteProjectResponse({ value, fee, memo }: sendMsgDeleteProjectResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgDeleteProjectResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgDeleteProjectResponse({ value: MsgDeleteProjectResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgDeleteProjectResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgCreateMilestone({ value, fee, memo }: sendMsgCreateMilestoneParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgCreateMilestone: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgCreateMilestone({ value: MsgCreateMilestone.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgCreateMilestone: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgDeleteMilestone({ value, fee, memo }: sendMsgDeleteMilestoneParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgDeleteMilestone: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgDeleteMilestone({ value: MsgDeleteMilestone.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgDeleteMilestone: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendGenesisState({ value, fee, memo }: sendGenesisStateParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendGenesisState: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.genesisState({ value: GenesisState.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendGenesisState: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryGetProjectRequest({ value, fee, memo }: sendQueryGetProjectRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryGetProjectRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryGetProjectRequest({ value: QueryGetProjectRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryGetProjectRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendProposal({ value, fee, memo }: sendProposalParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendProposal: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.proposal({ value: Proposal.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendProposal: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgUpdateProposal({ value, fee, memo }: sendMsgUpdateProposalParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgUpdateProposal: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgUpdateProposal({ value: MsgUpdateProposal.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgUpdateProposal: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryAllJobPostingRequest({ value, fee, memo }: sendQueryAllJobPostingRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryAllJobPostingRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryAllJobPostingRequest({ value: QueryAllJobPostingRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryAllJobPostingRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgUpdateProposalResponse({ value, fee, memo }: sendMsgUpdateProposalResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgUpdateProposalResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgUpdateProposalResponse({ value: MsgUpdateProposalResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgUpdateProposalResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryAllProjectRequest({ value, fee, memo }: sendQueryAllProjectRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryAllProjectRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryAllProjectRequest({ value: QueryAllProjectRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryAllProjectRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryGetMilestoneRequest({ value, fee, memo }: sendQueryGetMilestoneRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryGetMilestoneRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryGetMilestoneRequest({ value: QueryGetMilestoneRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryGetMilestoneRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryGetMilestoneResponse({ value, fee, memo }: sendQueryGetMilestoneResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryGetMilestoneResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryGetMilestoneResponse({ value: QueryGetMilestoneResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryGetMilestoneResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryListProposalsResponse({ value, fee, memo }: sendQueryListProposalsResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryListProposalsResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryListProposalsResponse({ value: QueryListProposalsResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryListProposalsResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryListProjectsRequest({ value, fee, memo }: sendQueryListProjectsRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryListProjectsRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryListProjectsRequest({ value: QueryListProjectsRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryListProjectsRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgCreateProposal({ value, fee, memo }: sendMsgCreateProposalParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgCreateProposal: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgCreateProposal({ value: MsgCreateProposal.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgCreateProposal: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgDeleteProposal({ value, fee, memo }: sendMsgDeleteProposalParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgDeleteProposal: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgDeleteProposal({ value: MsgDeleteProposal.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgDeleteProposal: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgReleasePaymentResponse({ value, fee, memo }: sendMsgReleasePaymentResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgReleasePaymentResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgReleasePaymentResponse({ value: MsgReleasePaymentResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgReleasePaymentResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryParamsResponse({ value, fee, memo }: sendQueryParamsResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryParamsResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryParamsResponse({ value: QueryParamsResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryParamsResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryGetProjectResponse({ value, fee, memo }: sendQueryGetProjectResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryGetProjectResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryGetProjectResponse({ value: QueryGetProjectResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryGetProjectResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgDeleteJobPosting({ value, fee, memo }: sendMsgDeleteJobPostingParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgDeleteJobPosting: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgDeleteJobPosting({ value: MsgDeleteJobPosting.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgDeleteJobPosting: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgCreateMilestoneResponse({ value, fee, memo }: sendMsgCreateMilestoneResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgCreateMilestoneResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgCreateMilestoneResponse({ value: MsgCreateMilestoneResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgCreateMilestoneResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgAcceptProposalResponse({ value, fee, memo }: sendMsgAcceptProposalResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgAcceptProposalResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgAcceptProposalResponse({ value: MsgAcceptProposalResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgAcceptProposalResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryAllProjectResponse({ value, fee, memo }: sendQueryAllProjectResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryAllProjectResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryAllProjectResponse({ value: QueryAllProjectResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryAllProjectResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryAllMilestoneRequest({ value, fee, memo }: sendQueryAllMilestoneRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryAllMilestoneRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryAllMilestoneRequest({ value: QueryAllMilestoneRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryAllMilestoneRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgCreateProposalResponse({ value, fee, memo }: sendMsgCreateProposalResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgCreateProposalResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgCreateProposalResponse({ value: MsgCreateProposalResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgCreateProposalResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendJobPosting({ value, fee, memo }: sendJobPostingParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendJobPosting: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.jobPosting({ value: JobPosting.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendJobPosting: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgDeleteProject({ value, fee, memo }: sendMsgDeleteProjectParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgDeleteProject: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgDeleteProject({ value: MsgDeleteProject.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgDeleteProject: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryGetProposalResponse({ value, fee, memo }: sendQueryGetProposalResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryGetProposalResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryGetProposalResponse({ value: QueryGetProposalResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryGetProposalResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryAllProposalResponse({ value, fee, memo }: sendQueryAllProposalResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryAllProposalResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryAllProposalResponse({ value: QueryAllProposalResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryAllProposalResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgUpdateProject({ value, fee, memo }: sendMsgUpdateProjectParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgUpdateProject: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgUpdateProject({ value: MsgUpdateProject.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgUpdateProject: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMilestone({ value, fee, memo }: sendMilestoneParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMilestone: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.milestone({ value: Milestone.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMilestone: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgCompleteMilestone({ value, fee, memo }: sendMsgCompleteMilestoneParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgCompleteMilestone: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgCompleteMilestone({ value: MsgCompleteMilestone.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgCompleteMilestone: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgDisputeProjectResponse({ value, fee, memo }: sendMsgDisputeProjectResponseParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgDisputeProjectResponse: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgDisputeProjectResponse({ value: MsgDisputeProjectResponse.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgDisputeProjectResponse: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryParamsRequest({ value, fee, memo }: sendQueryParamsRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryParamsRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryParamsRequest({ value: QueryParamsRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryParamsRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendQueryGetJobPostingRequest({ value, fee, memo }: sendQueryGetJobPostingRequestParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendQueryGetJobPostingRequest: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.queryGetJobPostingRequest({ value: QueryGetJobPostingRequest.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendQueryGetJobPostingRequest: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgUpdateJobPosting({ value, fee, memo }: sendMsgUpdateJobPostingParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgUpdateJobPosting: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgUpdateJobPosting({ value: MsgUpdateJobPosting.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgUpdateJobPosting: Could not broadcast Tx: '+ e.message)
			}
		},
		
		async sendMsgAcceptProposal({ value, fee, memo }: sendMsgAcceptProposalParams): Promise<DeliverTxResponse> {
			if (!signer) {
					throw new Error('TxClient:sendMsgAcceptProposal: Unable to sign Tx. Signer is not present.')
			}
			try {			
				const { address } = (await signer.getAccounts())[0]; 
				const signingClient = await SigningStargateClient.connectWithSigner(addr,signer,{registry});
				let msg = this.msgAcceptProposal({ value: MsgAcceptProposal.fromPartial(value) })
				return await signingClient.signAndBroadcast(address, [msg], fee ? fee : defaultFee, memo)
			} catch (e: any) {
				throw new Error('TxClient:sendMsgAcceptProposal: Could not broadcast Tx: '+ e.message)
			}
		},
		
		
		queryListJobPostingsResponse({ value }: queryListJobPostingsResponseParams): EncodeObject {
			try {
				return { typeUrl: "/skillchain.marketplace.QueryListJobPostingsResponse", value: QueryListJobPostingsResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryListJobPostingsResponse: Could not create message: ' + e.message)
			}
		},
		
		msgCreateProject({ value }: msgCreateProjectParams): EncodeObject {
			try {
				return { typeUrl: "/skillchain.marketplace.MsgCreateProject", value: MsgCreateProject.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgCreateProject: Could not create message: ' + e.message)
			}
		},
		
		msgDeleteProposalResponse({ value }: msgDeleteProposalResponseParams): EncodeObject {
			try {
				return { typeUrl: "/skillchain.marketplace.MsgDeleteProposalResponse", value: MsgDeleteProposalResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgDeleteProposalResponse: Could not create message: ' + e.message)
			}
		},
		
		msgUpdateMilestone({ value }: msgUpdateMilestoneParams): EncodeObject {
			try {
				return { typeUrl: "/skillchain.marketplace.MsgUpdateMilestone", value: MsgUpdateMilestone.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgUpdateMilestone: Could not create message: ' + e.message)
			}
		},
		
		msgDeleteMilestoneResponse({ value }: msgDeleteMilestoneResponseParams): EncodeObject {
			try {
				return { typeUrl: "/skillchain.marketplace.MsgDeleteMilestoneResponse", value: MsgDeleteMilestoneResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgDeleteMilestoneResponse: Could not create message: ' + e.message)
			}
		},
		
		msgCompleteMilestoneResponse({ value }: msgCompleteMilestoneResponseParams): EncodeObject {
			try {
				return { typeUrl: "/skillchain.marketplace.MsgCompleteMilestoneResponse", value: MsgCompleteMilestoneResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgCompleteMilestoneResponse: Could not create message: ' + e.message)
			}
		},
		
		msgDisputeProject({ value }: msgDisputeProjectParams): EncodeObject {
			try {
				return { typeUrl: "/skillchain.marketplace.MsgDisputeProject", value: MsgDisputeProject.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgDisputeProject: Could not create message: ' + e.message)
			}
		},
		
		msgCreateProjectResponse({ value }: msgCreateProjectResponseParams): EncodeObject {
			try {
				return { typeUrl: "/skillchain.marketplace.MsgCreateProjectResponse", value: MsgCreateProjectResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgCreateProjectResponse: Could not create message: ' + e.message)
			}
		},
		
		queryAllMilestoneResponse({ value }: queryAllMilestoneResponseParams): EncodeObject {
			try {
				return { typeUrl: "/skillchain.marketplace.QueryAllMilestoneResponse", value: QueryAllMilestoneResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryAllMilestoneResponse: Could not create message: ' + e.message)
			}
		},
		
		msgUpdateJobPostingResponse({ value }: msgUpdateJobPostingResponseParams): EncodeObject {
			try {
				return { typeUrl: "/skillchain.marketplace.MsgUpdateJobPostingResponse", value: MsgUpdateJobPostingResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgUpdateJobPostingResponse: Could not create message: ' + e.message)
			}
		},
		
		queryListJobPostingsRequest({ value }: queryListJobPostingsRequestParams): EncodeObject {
			try {
				return { typeUrl: "/skillchain.marketplace.QueryListJobPostingsRequest", value: QueryListJobPostingsRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryListJobPostingsRequest: Could not create message: ' + e.message)
			}
		},
		
		queryListProposalsRequest({ value }: queryListProposalsRequestParams): EncodeObject {
			try {
				return { typeUrl: "/skillchain.marketplace.QueryListProposalsRequest", value: QueryListProposalsRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryListProposalsRequest: Could not create message: ' + e.message)
			}
		},
		
		msgCreateJobPostingResponse({ value }: msgCreateJobPostingResponseParams): EncodeObject {
			try {
				return { typeUrl: "/skillchain.marketplace.MsgCreateJobPostingResponse", value: MsgCreateJobPostingResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgCreateJobPostingResponse: Could not create message: ' + e.message)
			}
		},
		
		msgDeleteJobPostingResponse({ value }: msgDeleteJobPostingResponseParams): EncodeObject {
			try {
				return { typeUrl: "/skillchain.marketplace.MsgDeleteJobPostingResponse", value: MsgDeleteJobPostingResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgDeleteJobPostingResponse: Could not create message: ' + e.message)
			}
		},
		
		msgReleasePayment({ value }: msgReleasePaymentParams): EncodeObject {
			try {
				return { typeUrl: "/skillchain.marketplace.MsgReleasePayment", value: MsgReleasePayment.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgReleasePayment: Could not create message: ' + e.message)
			}
		},
		
		queryAllJobPostingResponse({ value }: queryAllJobPostingResponseParams): EncodeObject {
			try {
				return { typeUrl: "/skillchain.marketplace.QueryAllJobPostingResponse", value: QueryAllJobPostingResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryAllJobPostingResponse: Could not create message: ' + e.message)
			}
		},
		
		queryGetProposalRequest({ value }: queryGetProposalRequestParams): EncodeObject {
			try {
				return { typeUrl: "/skillchain.marketplace.QueryGetProposalRequest", value: QueryGetProposalRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryGetProposalRequest: Could not create message: ' + e.message)
			}
		},
		
		project({ value }: projectParams): EncodeObject {
			try {
				return { typeUrl: "/skillchain.marketplace.Project", value: Project.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:Project: Could not create message: ' + e.message)
			}
		},
		
		msgUpdateMilestoneResponse({ value }: msgUpdateMilestoneResponseParams): EncodeObject {
			try {
				return { typeUrl: "/skillchain.marketplace.MsgUpdateMilestoneResponse", value: MsgUpdateMilestoneResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgUpdateMilestoneResponse: Could not create message: ' + e.message)
			}
		},
		
		params({ value }: paramsParams): EncodeObject {
			try {
				return { typeUrl: "/skillchain.marketplace.Params", value: Params.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:Params: Could not create message: ' + e.message)
			}
		},
		
		queryGetJobPostingResponse({ value }: queryGetJobPostingResponseParams): EncodeObject {
			try {
				return { typeUrl: "/skillchain.marketplace.QueryGetJobPostingResponse", value: QueryGetJobPostingResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryGetJobPostingResponse: Could not create message: ' + e.message)
			}
		},
		
		queryListProjectsResponse({ value }: queryListProjectsResponseParams): EncodeObject {
			try {
				return { typeUrl: "/skillchain.marketplace.QueryListProjectsResponse", value: QueryListProjectsResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryListProjectsResponse: Could not create message: ' + e.message)
			}
		},
		
		msgUpdateParams({ value }: msgUpdateParamsParams): EncodeObject {
			try {
				return { typeUrl: "/skillchain.marketplace.MsgUpdateParams", value: MsgUpdateParams.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgUpdateParams: Could not create message: ' + e.message)
			}
		},
		
		msgUpdateProjectResponse({ value }: msgUpdateProjectResponseParams): EncodeObject {
			try {
				return { typeUrl: "/skillchain.marketplace.MsgUpdateProjectResponse", value: MsgUpdateProjectResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgUpdateProjectResponse: Could not create message: ' + e.message)
			}
		},
		
		queryAllProposalRequest({ value }: queryAllProposalRequestParams): EncodeObject {
			try {
				return { typeUrl: "/skillchain.marketplace.QueryAllProposalRequest", value: QueryAllProposalRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryAllProposalRequest: Could not create message: ' + e.message)
			}
		},
		
		msgUpdateParamsResponse({ value }: msgUpdateParamsResponseParams): EncodeObject {
			try {
				return { typeUrl: "/skillchain.marketplace.MsgUpdateParamsResponse", value: MsgUpdateParamsResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgUpdateParamsResponse: Could not create message: ' + e.message)
			}
		},
		
		msgCreateJobPosting({ value }: msgCreateJobPostingParams): EncodeObject {
			try {
				return { typeUrl: "/skillchain.marketplace.MsgCreateJobPosting", value: MsgCreateJobPosting.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgCreateJobPosting: Could not create message: ' + e.message)
			}
		},
		
		msgDeleteProjectResponse({ value }: msgDeleteProjectResponseParams): EncodeObject {
			try {
				return { typeUrl: "/skillchain.marketplace.MsgDeleteProjectResponse", value: MsgDeleteProjectResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgDeleteProjectResponse: Could not create message: ' + e.message)
			}
		},
		
		msgCreateMilestone({ value }: msgCreateMilestoneParams): EncodeObject {
			try {
				return { typeUrl: "/skillchain.marketplace.MsgCreateMilestone", value: MsgCreateMilestone.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgCreateMilestone: Could not create message: ' + e.message)
			}
		},
		
		msgDeleteMilestone({ value }: msgDeleteMilestoneParams): EncodeObject {
			try {
				return { typeUrl: "/skillchain.marketplace.MsgDeleteMilestone", value: MsgDeleteMilestone.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgDeleteMilestone: Could not create message: ' + e.message)
			}
		},
		
		genesisState({ value }: genesisStateParams): EncodeObject {
			try {
				return { typeUrl: "/skillchain.marketplace.GenesisState", value: GenesisState.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:GenesisState: Could not create message: ' + e.message)
			}
		},
		
		queryGetProjectRequest({ value }: queryGetProjectRequestParams): EncodeObject {
			try {
				return { typeUrl: "/skillchain.marketplace.QueryGetProjectRequest", value: QueryGetProjectRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryGetProjectRequest: Could not create message: ' + e.message)
			}
		},
		
		proposal({ value }: proposalParams): EncodeObject {
			try {
				return { typeUrl: "/skillchain.marketplace.Proposal", value: Proposal.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:Proposal: Could not create message: ' + e.message)
			}
		},
		
		msgUpdateProposal({ value }: msgUpdateProposalParams): EncodeObject {
			try {
				return { typeUrl: "/skillchain.marketplace.MsgUpdateProposal", value: MsgUpdateProposal.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgUpdateProposal: Could not create message: ' + e.message)
			}
		},
		
		queryAllJobPostingRequest({ value }: queryAllJobPostingRequestParams): EncodeObject {
			try {
				return { typeUrl: "/skillchain.marketplace.QueryAllJobPostingRequest", value: QueryAllJobPostingRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryAllJobPostingRequest: Could not create message: ' + e.message)
			}
		},
		
		msgUpdateProposalResponse({ value }: msgUpdateProposalResponseParams): EncodeObject {
			try {
				return { typeUrl: "/skillchain.marketplace.MsgUpdateProposalResponse", value: MsgUpdateProposalResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgUpdateProposalResponse: Could not create message: ' + e.message)
			}
		},
		
		queryAllProjectRequest({ value }: queryAllProjectRequestParams): EncodeObject {
			try {
				return { typeUrl: "/skillchain.marketplace.QueryAllProjectRequest", value: QueryAllProjectRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryAllProjectRequest: Could not create message: ' + e.message)
			}
		},
		
		queryGetMilestoneRequest({ value }: queryGetMilestoneRequestParams): EncodeObject {
			try {
				return { typeUrl: "/skillchain.marketplace.QueryGetMilestoneRequest", value: QueryGetMilestoneRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryGetMilestoneRequest: Could not create message: ' + e.message)
			}
		},
		
		queryGetMilestoneResponse({ value }: queryGetMilestoneResponseParams): EncodeObject {
			try {
				return { typeUrl: "/skillchain.marketplace.QueryGetMilestoneResponse", value: QueryGetMilestoneResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryGetMilestoneResponse: Could not create message: ' + e.message)
			}
		},
		
		queryListProposalsResponse({ value }: queryListProposalsResponseParams): EncodeObject {
			try {
				return { typeUrl: "/skillchain.marketplace.QueryListProposalsResponse", value: QueryListProposalsResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryListProposalsResponse: Could not create message: ' + e.message)
			}
		},
		
		queryListProjectsRequest({ value }: queryListProjectsRequestParams): EncodeObject {
			try {
				return { typeUrl: "/skillchain.marketplace.QueryListProjectsRequest", value: QueryListProjectsRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryListProjectsRequest: Could not create message: ' + e.message)
			}
		},
		
		msgCreateProposal({ value }: msgCreateProposalParams): EncodeObject {
			try {
				return { typeUrl: "/skillchain.marketplace.MsgCreateProposal", value: MsgCreateProposal.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgCreateProposal: Could not create message: ' + e.message)
			}
		},
		
		msgDeleteProposal({ value }: msgDeleteProposalParams): EncodeObject {
			try {
				return { typeUrl: "/skillchain.marketplace.MsgDeleteProposal", value: MsgDeleteProposal.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgDeleteProposal: Could not create message: ' + e.message)
			}
		},
		
		msgReleasePaymentResponse({ value }: msgReleasePaymentResponseParams): EncodeObject {
			try {
				return { typeUrl: "/skillchain.marketplace.MsgReleasePaymentResponse", value: MsgReleasePaymentResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgReleasePaymentResponse: Could not create message: ' + e.message)
			}
		},
		
		queryParamsResponse({ value }: queryParamsResponseParams): EncodeObject {
			try {
				return { typeUrl: "/skillchain.marketplace.QueryParamsResponse", value: QueryParamsResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryParamsResponse: Could not create message: ' + e.message)
			}
		},
		
		queryGetProjectResponse({ value }: queryGetProjectResponseParams): EncodeObject {
			try {
				return { typeUrl: "/skillchain.marketplace.QueryGetProjectResponse", value: QueryGetProjectResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryGetProjectResponse: Could not create message: ' + e.message)
			}
		},
		
		msgDeleteJobPosting({ value }: msgDeleteJobPostingParams): EncodeObject {
			try {
				return { typeUrl: "/skillchain.marketplace.MsgDeleteJobPosting", value: MsgDeleteJobPosting.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgDeleteJobPosting: Could not create message: ' + e.message)
			}
		},
		
		msgCreateMilestoneResponse({ value }: msgCreateMilestoneResponseParams): EncodeObject {
			try {
				return { typeUrl: "/skillchain.marketplace.MsgCreateMilestoneResponse", value: MsgCreateMilestoneResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgCreateMilestoneResponse: Could not create message: ' + e.message)
			}
		},
		
		msgAcceptProposalResponse({ value }: msgAcceptProposalResponseParams): EncodeObject {
			try {
				return { typeUrl: "/skillchain.marketplace.MsgAcceptProposalResponse", value: MsgAcceptProposalResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgAcceptProposalResponse: Could not create message: ' + e.message)
			}
		},
		
		queryAllProjectResponse({ value }: queryAllProjectResponseParams): EncodeObject {
			try {
				return { typeUrl: "/skillchain.marketplace.QueryAllProjectResponse", value: QueryAllProjectResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryAllProjectResponse: Could not create message: ' + e.message)
			}
		},
		
		queryAllMilestoneRequest({ value }: queryAllMilestoneRequestParams): EncodeObject {
			try {
				return { typeUrl: "/skillchain.marketplace.QueryAllMilestoneRequest", value: QueryAllMilestoneRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryAllMilestoneRequest: Could not create message: ' + e.message)
			}
		},
		
		msgCreateProposalResponse({ value }: msgCreateProposalResponseParams): EncodeObject {
			try {
				return { typeUrl: "/skillchain.marketplace.MsgCreateProposalResponse", value: MsgCreateProposalResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgCreateProposalResponse: Could not create message: ' + e.message)
			}
		},
		
		jobPosting({ value }: jobPostingParams): EncodeObject {
			try {
				return { typeUrl: "/skillchain.marketplace.JobPosting", value: JobPosting.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:JobPosting: Could not create message: ' + e.message)
			}
		},
		
		msgDeleteProject({ value }: msgDeleteProjectParams): EncodeObject {
			try {
				return { typeUrl: "/skillchain.marketplace.MsgDeleteProject", value: MsgDeleteProject.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgDeleteProject: Could not create message: ' + e.message)
			}
		},
		
		queryGetProposalResponse({ value }: queryGetProposalResponseParams): EncodeObject {
			try {
				return { typeUrl: "/skillchain.marketplace.QueryGetProposalResponse", value: QueryGetProposalResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryGetProposalResponse: Could not create message: ' + e.message)
			}
		},
		
		queryAllProposalResponse({ value }: queryAllProposalResponseParams): EncodeObject {
			try {
				return { typeUrl: "/skillchain.marketplace.QueryAllProposalResponse", value: QueryAllProposalResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryAllProposalResponse: Could not create message: ' + e.message)
			}
		},
		
		msgUpdateProject({ value }: msgUpdateProjectParams): EncodeObject {
			try {
				return { typeUrl: "/skillchain.marketplace.MsgUpdateProject", value: MsgUpdateProject.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgUpdateProject: Could not create message: ' + e.message)
			}
		},
		
		milestone({ value }: milestoneParams): EncodeObject {
			try {
				return { typeUrl: "/skillchain.marketplace.Milestone", value: Milestone.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:Milestone: Could not create message: ' + e.message)
			}
		},
		
		msgCompleteMilestone({ value }: msgCompleteMilestoneParams): EncodeObject {
			try {
				return { typeUrl: "/skillchain.marketplace.MsgCompleteMilestone", value: MsgCompleteMilestone.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgCompleteMilestone: Could not create message: ' + e.message)
			}
		},
		
		msgDisputeProjectResponse({ value }: msgDisputeProjectResponseParams): EncodeObject {
			try {
				return { typeUrl: "/skillchain.marketplace.MsgDisputeProjectResponse", value: MsgDisputeProjectResponse.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgDisputeProjectResponse: Could not create message: ' + e.message)
			}
		},
		
		queryParamsRequest({ value }: queryParamsRequestParams): EncodeObject {
			try {
				return { typeUrl: "/skillchain.marketplace.QueryParamsRequest", value: QueryParamsRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryParamsRequest: Could not create message: ' + e.message)
			}
		},
		
		queryGetJobPostingRequest({ value }: queryGetJobPostingRequestParams): EncodeObject {
			try {
				return { typeUrl: "/skillchain.marketplace.QueryGetJobPostingRequest", value: QueryGetJobPostingRequest.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:QueryGetJobPostingRequest: Could not create message: ' + e.message)
			}
		},
		
		msgUpdateJobPosting({ value }: msgUpdateJobPostingParams): EncodeObject {
			try {
				return { typeUrl: "/skillchain.marketplace.MsgUpdateJobPosting", value: MsgUpdateJobPosting.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgUpdateJobPosting: Could not create message: ' + e.message)
			}
		},
		
		msgAcceptProposal({ value }: msgAcceptProposalParams): EncodeObject {
			try {
				return { typeUrl: "/skillchain.marketplace.MsgAcceptProposal", value: MsgAcceptProposal.fromPartial( value ) }  
			} catch (e: any) {
				throw new Error('TxClient:MsgAcceptProposal: Could not create message: ' + e.message)
			}
		},
		
	}
};

interface QueryClientOptions {
  addr: string
}

export const queryClient = ({ addr: addr }: QueryClientOptions = { addr: process.env.NEXT_PUBLIC_SKILLCHAIN_API || "http://45.83.20.3:1317" }) => {
  return new Api({ baseURL: addr });
};

class SDKModule {
	public query: ReturnType<typeof queryClient>;
	public tx: ReturnType<typeof txClient>;
	public structure: Record<string,unknown>;
	public registry: Array<[string, GeneratedType]> = [];

	constructor(client: IgniteClient) {		
	
		this.query = queryClient({ addr: client.env.apiURL });		
		this.updateTX(client);
		this.structure =  {
						JobPosting: getStructure(typeJobPosting.fromPartial({})),
						Milestone: getStructure(typeMilestone.fromPartial({})),
						Params: getStructure(typeParams.fromPartial({})),
						Project: getStructure(typeProject.fromPartial({})),
						Proposal: getStructure(typeProposal.fromPartial({})),
						
		};
		client.on('signer-changed',(signer) => {			
		 this.updateTX(client);
		})
	}
	updateTX(client: IgniteClient) {
    const methods = txClient({
        signer: client.signer,
        addr: client.env.rpcURL,
        prefix: client.env.prefix ?? "cosmos",
    })
	
    this.tx = methods;
    for (let m in methods) {
        this.tx[m] = methods[m].bind(this.tx);
    }
	}
};

const IgntModule = (test: IgniteClient) => {
	return {
		module: {
			SkillchainMarketplace: new SDKModule(test)
		},
		registry: msgTypes
  }
}
export default IgntModule;